        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>HtmlTokenizer class / tokenizer Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="tokenizer" data-type="HtmlTokenizer">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../tokenizer.html">tokenizer</a> &rsaquo; <a href="../tokenizer/HtmlTokenizer.html">HtmlTokenizer</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>HtmlTokenizer</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>This class takes care of tokenizing HTML.</p>
<pre class="source">
class HtmlTokenizer implements Iterator&lt;Token&gt; {
 // TODO(jmesserly): a lot of these could be made private

 final HtmlInputStream stream;

 final bool lowercaseElementName;

 final bool lowercaseAttrName;

 /** True to generate spans in for [Token.span]. */
 final bool generateSpans;

 /** True to generate spans for attributes. */
 final bool attributeSpans;

 /**
  * This reference to the parser is used for correct CDATA handling.
  * The [HtmlParser] will set this at construction time.
  */
 HtmlParser parser;

 final Queue&lt;Token&gt; tokenQueue;

 /** Holds the token that is currently being processed. */
 Token currentToken;

 /**
  * Holds a reference to the method to be invoked for the next parser state.
  */
 // TODO(jmesserly): the type should be "Predicate" but a dart2js checked mode
 // bug prevents us from doing that. See http://dartbug.com/12465
 Function state;

 String temporaryBuffer;

 int _lastOffset;

 // TODO(jmesserly): ideally this would be a LinkedHashMap and we wouldn't add
 // an item until it's ready. But the code doesn't have a clear notion of when
 // it's "done" with the attribute.
 List&lt;TagAttribute&gt; _attributes;
 Set&lt;String&gt; _attributeNames;

 HtmlTokenizer(doc, {String encoding, bool parseMeta: true,
     this.lowercaseElementName: true, this.lowercaseAttrName: true,
     bool generateSpans: false, String sourceUrl, this.attributeSpans: false})
     : stream = new HtmlInputStream(
           doc, encoding, parseMeta, generateSpans, sourceUrl),
       tokenQueue = new Queue(),
       generateSpans = generateSpans {
   reset();
 }

 TagToken get currentTagToken =&gt; currentToken;
 DoctypeToken get currentDoctypeToken =&gt; currentToken;
 StringToken get currentStringToken =&gt; currentToken;

 Token _current;
 Token get current =&gt; _current;

 String get _attributeName =&gt; _attributes.last.name;
 set _attributeName(String value) {
   _attributes.last.name = value;
 }

 String get _attributeValue =&gt; _attributes.last.value;
 set _attributeValue(String value) {
   _attributes.last.value = value;
 }

 void _markAttributeEnd(int offset) {
   if (attributeSpans) _attributes.last.end = stream.position + offset;
 }

 void _markAttributeValueStart(int offset) {
   if (attributeSpans) _attributes.last.startValue = stream.position + offset;
 }

 void _markAttributeValueEnd(int offset) {
   if (attributeSpans) {
     _attributes.last.endValue = stream.position + offset;
     _markAttributeEnd(offset);
   }
 }

 // Note: we could track the name span here, if we need it.
 void _markAttributeNameEnd(int offset) =&gt; _markAttributeEnd(offset);

 void _addAttribute(String name) {
   if (_attributes == null) _attributes = [];
   var attr = new TagAttribute(name);
   _attributes.add(attr);
   if (attributeSpans) attr.start = stream.position - name.length;
 }

 /**
  * This is where the magic happens.
  *
  * We do our usually processing through the states and when we have a token
  * to return we yield the token which pauses processing until the next token
  * is requested.
  */
 bool moveNext() {
   // Start processing. When EOF is reached state will return false;
   // instead of true and the loop will terminate.
   while (stream.errors.length == 0 &amp;&amp; tokenQueue.length == 0) {
     if (!state()) {
       _current = null;
       return false;
     }
   }
   if (stream.errors.length &gt; 0) {
     _current = new ParseErrorToken(stream.errors.removeFirst());
   } else {
     assert (tokenQueue.length &gt; 0);
     _current = tokenQueue.removeFirst();
   }
   return true;
 }

 /**
  * Resets the tokenizer state. Calling this does not reset the [stream] or
  * the [parser].
  */
 void reset() {
   _lastOffset = 0;
   tokenQueue.clear();
   currentToken = null;
   temporaryBuffer = null;
   _attributes = null;
   _attributeNames = null;
   state = dataState;
 }

 /** Adds a token to the queue. Sets the span if needed. */
 void _addToken(Token token) {
   if (generateSpans &amp;&amp; token.span == null) {
     int offset = stream.position;
     token.span = new FileSpan(stream.fileInfo, _lastOffset, offset);
     if (token is! ParseErrorToken) {
       _lastOffset = offset;
     }
   }
   tokenQueue.add(token);
 }

 /**
  * This function returns either U+FFFD or the character based on the
  * decimal or hexadecimal representation. It also discards ";" if present.
  * If not present it will add a [ParseErrorToken].
  */
 String consumeNumberEntity(bool isHex) {
   var allowed = isDigit;
   var radix = 10;
   if (isHex) {
     allowed = isHexDigit;
     radix = 16;
   }

   var charStack = [];

   // Consume all the characters that are in range while making sure we
   // don't hit an EOF.
   var c = stream.char();
   while (allowed(c) &amp;&amp; c != EOF) {
     charStack.add(c);
     c = stream.char();
   }

   // Convert the set of characters consumed to an int.
   var charAsInt = parseIntRadix(charStack.join(), radix);

   // Certain characters get replaced with others
   var char = replacementCharacters[charAsInt];
   if (char != null) {
     _addToken(new ParseErrorToken(
         "illegal-codepoint-for-numeric-entity",
         messageParams: {"charAsInt": charAsInt}));
   } else if ((0xD800 &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0xDFFF)
       || (charAsInt &gt; 0x10FFFF)) {
     char = "\uFFFD";
     _addToken(new ParseErrorToken(
         "illegal-codepoint-for-numeric-entity",
         messageParams: {"charAsInt": charAsInt}));
   } else {
     // Should speed up this check somehow (e.g. move the set to a constant)
     if ((0x0001 &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0x0008) ||
         (0x000E &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0x001F) ||
         (0x007F &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0x009F) ||
         (0xFDD0 &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0xFDEF) ||
         const [0x000B, 0xFFFE, 0xFFFF, 0x1FFFE,
               0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE,
               0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE,
               0x5FFFF, 0x6FFFE, 0x6FFFF, 0x7FFFE,
               0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE,
               0x9FFFF, 0xAFFFE, 0xAFFFF, 0xBFFFE,
               0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE,
               0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE,
               0xFFFFF, 0x10FFFE, 0x10FFFF].contains(charAsInt)) {
       _addToken(new ParseErrorToken(
           "illegal-codepoint-for-numeric-entity",
           messageParams: {"charAsInt": charAsInt}));
     }
     char = new String.fromCharCodes([charAsInt]);
   }

   // Discard the ; if present. Otherwise, put it back on the queue and
   // invoke parseError on parser.
   if (c != ";") {
     _addToken(new ParseErrorToken(
         "numeric-entity-without-semicolon"));
     stream.unget(c);
   }
   return char;
 }

 void consumeEntity({String allowedChar, bool fromAttribute: false}) {
   // Initialise to the default output for when no entity is matched
   var output = "&amp;";

   var charStack = [stream.char()];
   if (isWhitespace(charStack[0]) || charStack[0] == '&lt;' || charStack[0] == '&amp;'
       || charStack[0] == EOF || allowedChar == charStack[0]) {
     stream.unget(charStack[0]);
   } else if (charStack[0] == "#") {
     // Read the next character to see if it's hex or decimal
     bool hex = false;
     charStack.add(stream.char());
     if (charStack.last == 'x' || charStack.last == 'X') {
       hex = true;
       charStack.add(stream.char());
     }

     // charStack.last should be the first digit
     if (hex &amp;&amp; isHexDigit(charStack.last) ||
         (!hex &amp;&amp; isDigit(charStack.last))) {
       // At least one digit found, so consume the whole number
       stream.unget(charStack.last);
       output = consumeNumberEntity(hex);
     } else {
       // No digits found
       _addToken(new ParseErrorToken("expected-numeric-entity"));
       stream.unget(charStack.removeLast());
       output = "&amp;${charStack.join()}";
     }
   } else {
     // At this point in the process might have named entity. Entities
     // are stored in the global variable "entities".
     //
     // Consume characters and compare to these to a substring of the
     // entity names in the list until the substring no longer matches.
     var filteredEntityList = entitiesByFirstChar[charStack[0]];
     if (filteredEntityList == null) filteredEntityList = const [];

     while (charStack.last != EOF) {
       var name = charStack.join();
       filteredEntityList = filteredEntityList.where(
           (e) =&gt; e.startsWith(name)).toList();

       if (filteredEntityList.length == 0) {
         break;
       }
       charStack.add(stream.char());
     }

     // At this point we have a string that starts with some characters
     // that may match an entity
     String entityName = null;

     // Try to find the longest entity the string will match to take care
     // of &amp;noti for instance.

     int entityLen;
     for (entityLen = charStack.length - 1; entityLen &gt; 1; entityLen--) {
       var possibleEntityName = charStack.sublist(0, entityLen).join();
       if (entities.containsKey(possibleEntityName)) {
         entityName = possibleEntityName;
         break;
       }
     }

     if (entityName != null) {
       var lastChar = entityName[entityName.length - 1];
       if (lastChar != ";") {
         _addToken(new ParseErrorToken(
             "named-entity-without-semicolon"));
       }
       if (lastChar != ";" &amp;&amp; fromAttribute &amp;&amp;
           (isLetterOrDigit(charStack[entityLen]) ||
            charStack[entityLen] == '=')) {
         stream.unget(charStack.removeLast());
         output = "&amp;${charStack.join()}";
       } else {
         output = entities[entityName];
         stream.unget(charStack.removeLast());
         output = '${output}${slice(charStack, entityLen).join()}';
       }
     } else {
       _addToken(new ParseErrorToken("expected-named-entity"));
       stream.unget(charStack.removeLast());
       output = "&amp;${charStack.join()}";
     }
   }
   if (fromAttribute) {
     _attributeValue = '$_attributeValue$output';
   } else {
     var token;
     if (isWhitespace(output)) {
       token = new SpaceCharactersToken(output);
     } else {
       token = new CharactersToken(output);
     }
     _addToken(token);
   }
 }

 /** This method replaces the need for "entityInAttributeValueState". */
 void processEntityInAttribute(String allowedChar) {
   consumeEntity(allowedChar: allowedChar, fromAttribute: true);
 }

 /**
  * This method is a generic handler for emitting the tags. It also sets
  * the state to "data" because that's what's needed after a token has been
  * emitted.
  */
 void emitCurrentToken() {
   var token = currentToken;
   // Add token to the queue to be yielded
   if (token is TagToken) {
     if (lowercaseElementName) {
       token.name = asciiUpper2Lower(token.name);
     }
     if (token is EndTagToken) {
       if (_attributes != null) {
         _addToken(new ParseErrorToken("attributes-in-end-tag"));
       }
       if (token.selfClosing) {
         _addToken(new ParseErrorToken("this-closing-flag-on-end-tag"));
       }
     } else if (token is StartTagToken) {
       // HTML5 specific normalizations to the token stream.
       // Convert the list into a map where first key wins.
       token.data = new LinkedHashMap&lt;Object, String&gt;();
       if (_attributes != null) {
         for (var attr in _attributes) {
           token.data.putIfAbsent(attr.name, () =&gt; attr.value);
         }
         if (attributeSpans) token.attributeSpans = _attributes;
       }
     }
     _attributes = null;
     _attributeNames = null;
   }
   _addToken(token);
   state = dataState;
 }

 // Below are the various tokenizer states worked out.

 bool dataState() {
   var data = stream.char();
   if (data == "&amp;") {
     state = entityDataState;
   } else if (data == "&lt;") {
     state = tagOpenState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\u0000"));
   } else if (data == EOF) {
     // Tokenization ends.
     return false;
   } else if (isWhitespace(data)) {
     // Directly after emitting a token you switch back to the "data
     // state". At that point spaceCharacters are important so they are
     // emitted separately.
     _addToken(new SpaceCharactersToken(
         '${data}${stream.charsUntil(spaceCharacters, true)}'));
     // No need to update lastFourChars here, since the first space will
     // have already been appended to lastFourChars and will have broken
     // any &lt;!-- or --&gt; sequences
   } else {
     var chars = stream.charsUntil("&amp;&lt;\u0000");
     _addToken(new CharactersToken('${data}${chars}'));
   }
   return true;
 }

 bool entityDataState() {
   consumeEntity();
   state = dataState;
   return true;
 }

 bool rcdataState() {
   var data = stream.char();
   if (data == "&amp;") {
     state = characterReferenceInRcdata;
   } else if (data == "&lt;") {
     state = rcdataLessThanSignState;
   } else if (data == EOF) {
     // Tokenization ends.
     return false;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
   } else if (isWhitespace(data)) {
     // Directly after emitting a token you switch back to the "data
     // state". At that point spaceCharacters are important so they are
     // emitted separately.
     _addToken(new SpaceCharactersToken(
         '${data}${stream.charsUntil(spaceCharacters, true)}'));
   } else {
     var chars = stream.charsUntil("&amp;&lt;");
     _addToken(new CharactersToken('${data}${chars}'));
   }
   return true;
 }

 bool characterReferenceInRcdata() {
   consumeEntity();
   state = rcdataState;
   return true;
 }

 bool rawtextState() {
   var data = stream.char();
   if (data == "&lt;") {
     state = rawtextLessThanSignState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
   } else if (data == EOF) {
     // Tokenization ends.
     return false;
   } else {
     var chars = stream.charsUntil("&lt;\u0000");
     _addToken(new CharactersToken("${data}${chars}"));
   }
   return true;
 }

 bool scriptDataState() {
   var data = stream.char();
   if (data == "&lt;") {
     state = scriptDataLessThanSignState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
   } else if (data == EOF) {
     // Tokenization ends.
     return false;
   } else {
     var chars = stream.charsUntil("&lt;\u0000");
     _addToken(new CharactersToken("${data}${chars}"));
   }
   return true;
 }

 bool plaintextState() {
   var data = stream.char();
   if (data == EOF) {
     // Tokenization ends.
     return false;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
   } else {
     _addToken(new CharactersToken(
         '${data}${stream.charsUntil("\u0000")}'));
   }
   return true;
 }

 bool tagOpenState() {
   var data = stream.char();
   if (data == "!") {
     state = markupDeclarationOpenState;
   } else if (data == "/") {
     state = closeTagOpenState;
   } else if (isLetter(data)) {
     currentToken = new StartTagToken(data);
     state = tagNameState;
   } else if (data == "&gt;") {
     // XXX In theory it could be something besides a tag name. But
     // do we really care?
     _addToken(new ParseErrorToken(
         "expected-tag-name-but-got-right-bracket"));
     _addToken(new CharactersToken("&lt;&gt;"));
     state = dataState;
   } else if (data == "?") {
     // XXX In theory it could be something besides a tag name. But
     // do we really care?
     _addToken(new ParseErrorToken(
         "expected-tag-name-but-got-question-mark"));
     stream.unget(data);
     state = bogusCommentState;
   } else {
     // XXX
     _addToken(new ParseErrorToken("expected-tag-name"));
     _addToken(new CharactersToken("&lt;"));
     stream.unget(data);
     state = dataState;
   }
   return true;
 }

 bool closeTagOpenState() {
   var data = stream.char();
   if (isLetter(data)) {
     currentToken = new EndTagToken(data);
     state = tagNameState;
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken(
         "expected-closing-tag-but-got-right-bracket"));
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken(
         "expected-closing-tag-but-got-eof"));
     _addToken(new CharactersToken("&lt;/"));
     state = dataState;
   } else {
     // XXX data can be _'_...
     _addToken(new ParseErrorToken(
         "expected-closing-tag-but-got-char", messageParams: {"data": data}));
     stream.unget(data);
     state = bogusCommentState;
   }
   return true;
 }

 bool tagNameState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     state = beforeAttributeNameState;
   } else if (data == "&gt;") {
     emitCurrentToken();
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-tag-name"));
     state = dataState;
   } else if (data == "/") {
     state = selfClosingStartTagState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentTagToken.name = '${currentTagToken.name}\uFFFD';
   } else {
     currentTagToken.name = '${currentTagToken.name}$data';
     // (Don't use charsUntil here, because tag names are
     // very short and it's faster to not do anything fancy)
   }
   return true;
 }

 bool rcdataLessThanSignState() {
   var data = stream.char();
   if (data == "/") {
     temporaryBuffer = "";
     state = rcdataEndTagOpenState;
   } else {
     _addToken(new CharactersToken("&lt;"));
     stream.unget(data);
     state = rcdataState;
   }
   return true;
 }

 bool rcdataEndTagOpenState() {
   var data = stream.char();
   if (isLetter(data)) {
     temporaryBuffer = '${temporaryBuffer}$data';
     state = rcdataEndTagNameState;
   } else {
     _addToken(new CharactersToken("&lt;/"));
     stream.unget(data);
     state = rcdataState;
   }
   return true;
 }

 bool _tokenIsAppropriate() {
   return currentToken is TagToken &amp;&amp;
       currentTagToken.name.toLowerCase() == temporaryBuffer.toLowerCase();
 }

 bool rcdataEndTagNameState() {
   var appropriate = _tokenIsAppropriate();
   var data = stream.char();
   if (isWhitespace(data) &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     state = beforeAttributeNameState;
   } else if (data == "/" &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     state = selfClosingStartTagState;
   } else if (data == "&gt;" &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     emitCurrentToken();
     state = dataState;
   } else if (isLetter(data)) {
     temporaryBuffer = '${temporaryBuffer}$data';
   } else {
     _addToken(new CharactersToken("&lt;/$temporaryBuffer"));
     stream.unget(data);
     state = rcdataState;
   }
   return true;
 }

 bool rawtextLessThanSignState() {
   var data = stream.char();
   if (data == "/") {
     temporaryBuffer = "";
     state = rawtextEndTagOpenState;
   } else {
     _addToken(new CharactersToken("&lt;"));
     stream.unget(data);
     state = rawtextState;
   }
   return true;
 }

 bool rawtextEndTagOpenState() {
   var data = stream.char();
   if (isLetter(data)) {
     temporaryBuffer = '${temporaryBuffer}$data';
     state = rawtextEndTagNameState;
   } else {
     _addToken(new CharactersToken("&lt;/"));
     stream.unget(data);
     state = rawtextState;
   }
   return true;
 }

 bool rawtextEndTagNameState() {
   var appropriate = _tokenIsAppropriate();
   var data = stream.char();
   if (isWhitespace(data) &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     state = beforeAttributeNameState;
   } else if (data == "/" &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     state = selfClosingStartTagState;
   } else if (data == "&gt;" &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     emitCurrentToken();
     state = dataState;
   } else if (isLetter(data)) {
     temporaryBuffer = '${temporaryBuffer}$data';
   } else {
     _addToken(new CharactersToken("&lt;/$temporaryBuffer"));
     stream.unget(data);
     state = rawtextState;
   }
   return true;
 }

 bool scriptDataLessThanSignState() {
   var data = stream.char();
   if (data == "/") {
     temporaryBuffer = "";
     state = scriptDataEndTagOpenState;
   } else if (data == "!") {
     _addToken(new CharactersToken("&lt;!"));
     state = scriptDataEscapeStartState;
   } else {
     _addToken(new CharactersToken("&lt;"));
     stream.unget(data);
     state = scriptDataState;
   }
   return true;
 }

 bool scriptDataEndTagOpenState() {
   var data = stream.char();
   if (isLetter(data)) {
     temporaryBuffer = '${temporaryBuffer}$data';
     state = scriptDataEndTagNameState;
   } else {
     _addToken(new CharactersToken("&lt;/"));
     stream.unget(data);
     state = scriptDataState;
   }
   return true;
 }

 bool scriptDataEndTagNameState() {
   var appropriate = _tokenIsAppropriate();
   var data = stream.char();
   if (isWhitespace(data) &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     state = beforeAttributeNameState;
   } else if (data == "/" &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     state = selfClosingStartTagState;
   } else if (data == "&gt;" &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     emitCurrentToken();
     state = dataState;
   } else if (isLetter(data)) {
     temporaryBuffer = '${temporaryBuffer}$data';
   } else {
     _addToken(new CharactersToken("&lt;/$temporaryBuffer"));
     stream.unget(data);
     state = scriptDataState;
   }
   return true;
 }

 bool scriptDataEscapeStartState() {
   var data = stream.char();
   if (data == "-") {
     _addToken(new CharactersToken("-"));
     state = scriptDataEscapeStartDashState;
   } else {
     stream.unget(data);
     state = scriptDataState;
   }
   return true;
 }

 bool scriptDataEscapeStartDashState() {
   var data = stream.char();
   if (data == "-") {
     _addToken(new CharactersToken("-"));
     state = scriptDataEscapedDashDashState;
   } else {
     stream.unget(data);
     state = scriptDataState;
   }
   return true;
 }

 bool scriptDataEscapedState() {
   var data = stream.char();
   if (data == "-") {
     _addToken(new CharactersToken("-"));
     state = scriptDataEscapedDashState;
   } else if (data == "&lt;") {
     state = scriptDataEscapedLessThanSignState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
   } else if (data == EOF) {
     state = dataState;
   } else {
     var chars = stream.charsUntil("&lt;-\u0000");
     _addToken(new CharactersToken("${data}${chars}"));
   }
   return true;
 }

 bool scriptDataEscapedDashState() {
   var data = stream.char();
   if (data == "-") {
     _addToken(new CharactersToken("-"));
     state = scriptDataEscapedDashDashState;
   } else if (data == "&lt;") {
     state = scriptDataEscapedLessThanSignState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
     state = scriptDataEscapedState;
   } else if (data == EOF) {
     state = dataState;
   } else {
     _addToken(new CharactersToken(data));
     state = scriptDataEscapedState;
   }
   return true;
 }

 bool scriptDataEscapedDashDashState() {
   var data = stream.char();
   if (data == "-") {
     _addToken(new CharactersToken("-"));
   } else if (data == "&lt;") {
     state = scriptDataEscapedLessThanSignState;
   } else if (data == "&gt;") {
     _addToken(new CharactersToken("&gt;"));
     state = scriptDataState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
     state = scriptDataEscapedState;
   } else if (data == EOF) {
     state = dataState;
   } else {
     _addToken(new CharactersToken(data));
     state = scriptDataEscapedState;
   }
   return true;
 }

 bool scriptDataEscapedLessThanSignState() {
   var data = stream.char();
   if (data == "/") {
     temporaryBuffer = "";
     state = scriptDataEscapedEndTagOpenState;
   } else if (isLetter(data)) {
     _addToken(new CharactersToken("&lt;$data"));
     temporaryBuffer = data;
     state = scriptDataDoubleEscapeStartState;
   } else {
     _addToken(new CharactersToken("&lt;"));
     stream.unget(data);
     state = scriptDataEscapedState;
   }
   return true;
 }

 bool scriptDataEscapedEndTagOpenState() {
   var data = stream.char();
   if (isLetter(data)) {
     temporaryBuffer = data;
     state = scriptDataEscapedEndTagNameState;
   } else {
     _addToken(new CharactersToken("&lt;/"));
     stream.unget(data);
     state = scriptDataEscapedState;
   }
   return true;
 }

 bool scriptDataEscapedEndTagNameState() {
   var appropriate = _tokenIsAppropriate();
   var data = stream.char();
   if (isWhitespace(data) &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     state = beforeAttributeNameState;
   } else if (data == "/" &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     state = selfClosingStartTagState;
   } else if (data == "&gt;" &amp;&amp; appropriate) {
     currentToken = new EndTagToken(temporaryBuffer);
     emitCurrentToken();
     state = dataState;
   } else if (isLetter(data)) {
     temporaryBuffer = '${temporaryBuffer}$data';
   } else {
     _addToken(new CharactersToken("&lt;/$temporaryBuffer"));
     stream.unget(data);
     state = scriptDataEscapedState;
   }
   return true;
 }

 bool scriptDataDoubleEscapeStartState() {
   var data = stream.char();
   if (isWhitespace(data) || data == "/" || data == "&gt;") {
     _addToken(new CharactersToken(data));
     if (temporaryBuffer.toLowerCase() == "script") {
       state = scriptDataDoubleEscapedState;
     } else {
       state = scriptDataEscapedState;
     }
   } else if (isLetter(data)) {
     _addToken(new CharactersToken(data));
     temporaryBuffer = '${temporaryBuffer}$data';
   } else {
     stream.unget(data);
     state = scriptDataEscapedState;
   }
   return true;
 }

 bool scriptDataDoubleEscapedState() {
   var data = stream.char();
   if (data == "-") {
     _addToken(new CharactersToken("-"));
     state = scriptDataDoubleEscapedDashState;
   } else if (data == "&lt;") {
     _addToken(new CharactersToken("&lt;"));
     state = scriptDataDoubleEscapedLessThanSignState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-script-in-script"));
     state = dataState;
   } else {
     _addToken(new CharactersToken(data));
   }
   return true;
 }

 bool scriptDataDoubleEscapedDashState() {
   var data = stream.char();
   if (data == "-") {
     _addToken(new CharactersToken("-"));
     state = scriptDataDoubleEscapedDashDashState;
   } else if (data == "&lt;") {
     _addToken(new CharactersToken("&lt;"));
     state = scriptDataDoubleEscapedLessThanSignState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
     state = scriptDataDoubleEscapedState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-script-in-script"));
     state = dataState;
   } else {
     _addToken(new CharactersToken(data));
     state = scriptDataDoubleEscapedState;
   }
   return true;
 }

 // TODO(jmesserly): report bug in original code
 // (was "Dash" instead of "DashDash")
 bool scriptDataDoubleEscapedDashDashState() {
   var data = stream.char();
   if (data == "-") {
     _addToken(new CharactersToken("-"));
   } else if (data == "&lt;") {
     _addToken(new CharactersToken("&lt;"));
     state = scriptDataDoubleEscapedLessThanSignState;
   } else if (data == "&gt;") {
     _addToken(new CharactersToken("&gt;"));
     state = scriptDataState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addToken(new CharactersToken("\uFFFD"));
     state = scriptDataDoubleEscapedState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-script-in-script"));
     state = dataState;
   } else {
     _addToken(new CharactersToken(data));
     state = scriptDataDoubleEscapedState;
   }
   return true;
 }

 bool scriptDataDoubleEscapedLessThanSignState() {
   var data = stream.char();
   if (data == "/") {
     _addToken(new CharactersToken("/"));
     temporaryBuffer = "";
     state = scriptDataDoubleEscapeEndState;
   } else {
     stream.unget(data);
     state = scriptDataDoubleEscapedState;
   }
   return true;
 }

 bool scriptDataDoubleEscapeEndState() {
   var data = stream.char();
   if (isWhitespace(data) || data == "/" || data == "&gt;") {
     _addToken(new CharactersToken(data));
     if (temporaryBuffer.toLowerCase() == "script") {
       state = scriptDataEscapedState;
     } else {
       state = scriptDataDoubleEscapedState;
     }
   } else if (isLetter(data)) {
     _addToken(new CharactersToken(data));
     temporaryBuffer = '${temporaryBuffer}$data';
   } else {
     stream.unget(data);
     state = scriptDataDoubleEscapedState;
   }
   return true;
 }

 bool beforeAttributeNameState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     stream.charsUntil(spaceCharacters, true);
   } else if (isLetter(data)) {
     _addAttribute(data);
     state = attributeNameState;
   } else if (data == "&gt;") {
     emitCurrentToken();
   } else if (data == "/") {
     state = selfClosingStartTagState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("expected-attribute-name-but-got-eof"));
     state = dataState;
   } else if ("'\"=&lt;".contains(data)) {
     _addToken(new ParseErrorToken("invalid-character-in-attribute-name"));
     _addAttribute(data);
     state = attributeNameState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addAttribute("\uFFFD");
     state = attributeNameState;
   } else {
     _addAttribute(data);
     state = attributeNameState;
   }
   return true;
 }

 bool attributeNameState() {
   var data = stream.char();
   bool leavingThisState = true;
   bool emitToken = false;
   if (data == "=") {
     state = beforeAttributeValueState;
   } else if (isLetter(data)) {
     _attributeName = '$_attributeName$data'
         '${stream.charsUntil(asciiLetters, true)}';
     leavingThisState = false;
   } else if (data == "&gt;") {
     // XXX If we emit here the attributes are converted to a dict
     // without being checked and when the code below runs we error
     // because data is a dict not a list
     emitToken = true;
   } else if (isWhitespace(data)) {
     state = afterAttributeNameState;
   } else if (data == "/") {
     state = selfClosingStartTagState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _attributeName = '${_attributeName}\uFFFD';
     leavingThisState = false;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-attribute-name"));
     state = dataState;
   } else if ("'\"&lt;".contains(data)) {
     _addToken(new ParseErrorToken("invalid-character-in-attribute-name"));
     _attributeName = '$_attributeName$data';
     leavingThisState = false;
   } else {
     _attributeName = '$_attributeName$data';
     leavingThisState = false;
   }

   if (leavingThisState) {
     _markAttributeNameEnd(-1);

     // Attributes are not dropped at this stage. That happens when the
     // start tag token is emitted so values can still be safely appended
     // to attributes, but we do want to report the parse error in time.
     if (lowercaseAttrName) {
       _attributeName = asciiUpper2Lower(_attributeName);
     }
     if (_attributeNames == null) _attributeNames = new Set();
     if (_attributeNames.contains(_attributeName)) {
       _addToken(new ParseErrorToken("duplicate-attribute"));
     }
     _attributeNames.add(_attributeName);

     // XXX Fix for above XXX
     if (emitToken) {
       emitCurrentToken();
     }
   }
   return true;
 }

 bool afterAttributeNameState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     stream.charsUntil(spaceCharacters, true);
   } else if (data == "=") {
     state = beforeAttributeValueState;
   } else if (data == "&gt;") {
     emitCurrentToken();
   } else if (isLetter(data)) {
     _addAttribute(data);
     state = attributeNameState;
   } else if (data == "/") {
     state = selfClosingStartTagState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _addAttribute("\uFFFD");
     state = attributeNameState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("expected-end-of-tag-but-got-eof"));
     state = dataState;
   } else if ("'\"&lt;".contains(data)) {
     _addToken(new ParseErrorToken("invalid-character-after-attribute-name"));
     _addAttribute(data);
     state = attributeNameState;
   } else {
     _addAttribute(data);
     state = attributeNameState;
   }
   return true;
 }

 bool beforeAttributeValueState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     stream.charsUntil(spaceCharacters, true);
   } else if (data == "\"") {
     _markAttributeValueStart(0);
     state = attributeValueDoubleQuotedState;
   } else if (data == "&amp;") {
     state = attributeValueUnQuotedState;
     stream.unget(data);
     _markAttributeValueStart(0);
   } else if (data == "'") {
     _markAttributeValueStart(0);
     state = attributeValueSingleQuotedState;
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken(
         "expected-attribute-value-but-got-right-bracket"));
     emitCurrentToken();
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _markAttributeValueStart(-1);
     _attributeValue = '${_attributeValue}\uFFFD';
     state = attributeValueUnQuotedState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("expected-attribute-value-but-got-eof"));
     state = dataState;
   } else if ("=&lt;`".contains(data)) {
     _addToken(new ParseErrorToken("equals-in-unquoted-attribute-value"));
     _markAttributeValueStart(-1);
     _attributeValue = '$_attributeValue$data';
     state = attributeValueUnQuotedState;
   } else {
     _markAttributeValueStart(-1);
     _attributeValue = '$_attributeValue$data';
     state = attributeValueUnQuotedState;
   }
   return true;
 }

 bool attributeValueDoubleQuotedState() {
   var data = stream.char();
   if (data == "\"") {
     _markAttributeValueEnd(-1);
     _markAttributeEnd(0);
     state = afterAttributeValueState;
   } else if (data == "&amp;") {
     processEntityInAttribute('"');
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _attributeValue = '${_attributeValue}\uFFFD';
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-attribute-value-double-quote"));
     _markAttributeValueEnd(-1);
     state = dataState;
   } else {
     _attributeValue = '$_attributeValue$data${stream.charsUntil("\"&amp;")}';
   }
   return true;
 }

 bool attributeValueSingleQuotedState() {
   var data = stream.char();
   if (data == "'") {
     _markAttributeValueEnd(-1);
     _markAttributeEnd(0);
     state = afterAttributeValueState;
   } else if (data == "&amp;") {
     processEntityInAttribute("'");
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _attributeValue = '${_attributeValue}\uFFFD';
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-attribute-value-single-quote"));
     _markAttributeValueEnd(-1);
     state = dataState;
   } else {
     _attributeValue = '$_attributeValue$data${stream.charsUntil("\'&amp;")}';
   }
   return true;
 }

 bool attributeValueUnQuotedState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     _markAttributeValueEnd(-1);
     state = beforeAttributeNameState;
   } else if (data == "&amp;") {
     processEntityInAttribute("&gt;");
   } else if (data == "&gt;") {
     _markAttributeValueEnd(-1);
     emitCurrentToken();
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-attribute-value-no-quotes"));
     _markAttributeValueEnd(-1);
     state = dataState;
   } else if ('"\'=&lt;`'.contains(data)) {
     _addToken(new ParseErrorToken(
         "unexpected-character-in-unquoted-attribute-value"));
     _attributeValue = '$_attributeValue$data';
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     _attributeValue = '${_attributeValue}\uFFFD';
   } else {
     _attributeValue = '$_attributeValue$data'
         '${stream.charsUntil("&amp;&gt;\"\'=&lt;`$spaceCharacters")}';
   }
   return true;
 }

 bool afterAttributeValueState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     state = beforeAttributeNameState;
   } else if (data == "&gt;") {
     emitCurrentToken();
   } else if (data == "/") {
     state = selfClosingStartTagState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("unexpected-EOF-after-attribute-value"));
     stream.unget(data);
     state = dataState;
   } else {
     _addToken(new ParseErrorToken(
         "unexpected-character-after-attribute-value"));
     stream.unget(data);
     state = beforeAttributeNameState;
   }
   return true;
 }

 bool selfClosingStartTagState() {
   var data = stream.char();
   if (data == "&gt;") {
     currentTagToken.selfClosing = true;
     emitCurrentToken();
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("unexpected-EOF-after-solidus-in-tag"));
     stream.unget(data);
     state = dataState;
   } else {
     _addToken(new ParseErrorToken(
         "unexpected-character-after-soldius-in-tag"));
     stream.unget(data);
     state = beforeAttributeNameState;
   }
   return true;
 }

 bool bogusCommentState() {
   // Make a new comment token and give it as value all the characters
   // until the first &gt; or EOF (charsUntil checks for EOF automatically)
   // and emit it.
   var data = stream.charsUntil("&gt;");
   data = data.replaceAll("\u0000", "\uFFFD");
   _addToken(new CommentToken(data));

   // Eat the character directly after the bogus comment which is either a
   // "&gt;" or an EOF.
   stream.char();
   state = dataState;
   return true;
 }

 bool markupDeclarationOpenState() {
   var charStack = [stream.char()];
   if (charStack.last == "-") {
     charStack.add(stream.char());
     if (charStack.last == "-") {
       currentToken = new CommentToken("");
       state = commentStartState;
       return true;
     }
   } else if (charStack.last == 'd' || charStack.last == 'D') {
     var matched = true;
     for (var expected in const ['oO', 'cC', 'tT', 'yY', 'pP', 'eE']) {
       var char = stream.char();
       charStack.add(char);
       if (char == EOF || !expected.contains(char)) {
         matched = false;
         break;
       }
     }
     if (matched) {
       currentToken = new DoctypeToken(correct: true);
       state = doctypeState;
       return true;
     }
   } else if (charStack.last == "[" &amp;&amp;
       parser != null &amp;&amp; parser.tree.openElements.length &gt; 0 &amp;&amp;
       parser.tree.openElements.last.namespace
           != parser.tree.defaultNamespace) {
     var matched = true;
     for (var expected in const ["C", "D", "A", "T", "A", "["]) {
       charStack.add(stream.char());
       if (charStack.last != expected) {
         matched = false;
         break;
       }
     }
     if (matched) {
       state = cdataSectionState;
       return true;
     }
   }

   _addToken(new ParseErrorToken("expected-dashes-or-doctype"));

   while (charStack.length &gt; 0) {
     stream.unget(charStack.removeLast());
   }
   state = bogusCommentState;
   return true;
 }

 bool commentStartState() {
   var data = stream.char();
   if (data == "-") {
     state = commentStartDashState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentStringToken.data = '${currentStringToken.data}\uFFFD';
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken("incorrect-comment"));
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-comment"));
     _addToken(currentToken);
     state = dataState;
   } else {
     currentStringToken.data = '${currentStringToken.data}$data';
     state = commentState;
   }
   return true;
 }

 bool commentStartDashState() {
   var data = stream.char();
   if (data == "-") {
     state = commentEndState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentStringToken.data = '${currentStringToken.data}-\uFFFD';
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken("incorrect-comment"));
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-comment"));
     _addToken(currentToken);
     state = dataState;
   } else {
     currentStringToken.data = '${currentStringToken.data}-${data}';
     state = commentState;
   }
   return true;
 }

 bool commentState() {
   var data = stream.char();
   if (data == "-") {
     state = commentEndDashState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentStringToken.data = '${currentStringToken.data}\uFFFD';
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-comment"));
     _addToken(currentToken);
     state = dataState;
   } else {
     currentStringToken.data = '${currentStringToken.data}$data'
         '${stream.charsUntil("-\u0000")}';
   }
   return true;
 }

 bool commentEndDashState() {
   var data = stream.char();
   if (data == "-") {
     state = commentEndState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentStringToken.data = "${currentStringToken.data}-\uFFFD";
     state = commentState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-comment-end-dash"));
     _addToken(currentToken);
     state = dataState;
   } else {
     currentStringToken.data = "${currentStringToken.data}-${data}";
     state = commentState;
   }
   return true;
 }

 bool commentEndState() {
   var data = stream.char();
   if (data == "&gt;") {
     _addToken(currentToken);
     state = dataState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentStringToken.data = '${currentStringToken.data}--\uFFFD';
     state = commentState;
   } else if (data == "!") {
     _addToken(new ParseErrorToken(
         "unexpected-bang-after-double-dash-in-comment"));
     state = commentEndBangState;
   } else if (data == "-") {
     _addToken(new ParseErrorToken(
         "unexpected-dash-after-double-dash-in-comment"));
     currentStringToken.data = '${currentStringToken.data}$data';
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-comment-double-dash"));
     _addToken(currentToken);
     state = dataState;
   } else {
     // XXX
     _addToken(new ParseErrorToken("unexpected-char-in-comment"));
     currentStringToken.data = "${currentStringToken.data}--${data}";
     state = commentState;
   }
   return true;
 }

 bool commentEndBangState() {
   var data = stream.char();
   if (data == "&gt;") {
     _addToken(currentToken);
     state = dataState;
   } else if (data == "-") {
     currentStringToken.data = '${currentStringToken.data}--!';
     state = commentEndDashState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentStringToken.data = '${currentStringToken.data}--!\uFFFD';
     state = commentState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-comment-end-bang-state"));
     _addToken(currentToken);
     state = dataState;
   } else {
     currentStringToken.data = "${currentStringToken.data}--!${data}";
     state = commentState;
   }
   return true;
 }

 bool doctypeState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     state = beforeDoctypeNameState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken(
         "expected-doctype-name-but-got-eof"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     _addToken(new ParseErrorToken("need-space-after-doctype"));
     stream.unget(data);
     state = beforeDoctypeNameState;
   }
   return true;
 }

 bool beforeDoctypeNameState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     return true;
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken(
         "expected-doctype-name-but-got-right-bracket"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentDoctypeToken.name = "\uFFFD";
     state = doctypeNameState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken(
         "expected-doctype-name-but-got-eof"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     currentDoctypeToken.name = data;
     state = doctypeNameState;
   }
   return true;
 }

 bool doctypeNameState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     currentDoctypeToken.name = asciiUpper2Lower(currentDoctypeToken.name);
     state = afterDoctypeNameState;
   } else if (data == "&gt;") {
     currentDoctypeToken.name = asciiUpper2Lower(currentDoctypeToken.name);
     _addToken(currentToken);
     state = dataState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentDoctypeToken.name = "${currentDoctypeToken.name}\uFFFD";
     state = doctypeNameState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype-name"));
     currentDoctypeToken.correct = false;
     currentDoctypeToken.name = asciiUpper2Lower(currentDoctypeToken.name);
     _addToken(currentToken);
     state = dataState;
   } else {
     currentDoctypeToken.name = '${currentDoctypeToken.name}$data';
   }
   return true;
 }

 bool afterDoctypeNameState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     return true;
   } else if (data == "&gt;") {
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     currentDoctypeToken.correct = false;
     stream.unget(data);
     _addToken(new ParseErrorToken("eof-in-doctype"));
     _addToken(currentToken);
     state = dataState;
   } else {
     if (data == "p" || data == "P") {
       // TODO(jmesserly): would be nice to have a helper for this.
       var matched = true;
       for (var expected in const ["uU", "bB", "lL", "iI", "cC"]) {
         data = stream.char();
         if (data == EOF || !expected.contains(data)) {
           matched = false;
           break;
         }
       }
       if (matched) {
         state = afterDoctypePublicKeywordState;
         return true;
       }
     } else if (data == "s" || data == "S") {
       var matched = true;
       for (var expected in const ["yY", "sS", "tT", "eE", "mM"]) {
         data = stream.char();
         if (data == EOF || !expected.contains(data)) {
           matched = false;
           break;
         }
       }
       if (matched) {
         state = afterDoctypeSystemKeywordState;
         return true;
       }
     }

     // All the characters read before the current 'data' will be
     // [a-zA-Z], so they're garbage in the bogus doctype and can be
     // discarded; only the latest character might be '&gt;' or EOF
     // and needs to be ungetted
     stream.unget(data);
     _addToken(new ParseErrorToken(
         "expected-space-or-right-bracket-in-doctype",
         messageParams: {"data": data}));
     currentDoctypeToken.correct = false;
     state = bogusDoctypeState;
   }
   return true;
 }

 bool afterDoctypePublicKeywordState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     state = beforeDoctypePublicIdentifierState;
   } else if (data == "'" || data == '"') {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     stream.unget(data);
     state = beforeDoctypePublicIdentifierState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     stream.unget(data);
     state = beforeDoctypePublicIdentifierState;
   }
   return true;
 }

 bool beforeDoctypePublicIdentifierState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     return true;
   } else if (data == "\"") {
     currentDoctypeToken.publicId = "";
     state = doctypePublicIdentifierDoubleQuotedState;
   } else if (data == "'") {
     currentDoctypeToken.publicId = "";
     state = doctypePublicIdentifierSingleQuotedState;
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     currentDoctypeToken.correct = false;
     state = bogusDoctypeState;
   }
   return true;
 }

 bool doctypePublicIdentifierDoubleQuotedState() {
   var data = stream.char();
   if (data == '"') {
     state = afterDoctypePublicIdentifierState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentDoctypeToken.publicId = "${currentDoctypeToken.publicId}\uFFFD";
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     currentDoctypeToken.publicId = '${currentDoctypeToken.publicId}$data';
   }
   return true;
 }

 bool doctypePublicIdentifierSingleQuotedState() {
   var data = stream.char();
   if (data == "'") {
     state = afterDoctypePublicIdentifierState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentDoctypeToken.publicId = "${currentDoctypeToken.publicId}\uFFFD";
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     currentDoctypeToken.publicId = '${currentDoctypeToken.publicId}$data';
   }
   return true;
 }

 bool afterDoctypePublicIdentifierState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     state = betweenDoctypePublicAndSystemIdentifiersState;
   } else if (data == "&gt;") {
     _addToken(currentToken);
     state = dataState;
   } else if (data == '"') {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     currentDoctypeToken.systemId = "";
     state = doctypeSystemIdentifierDoubleQuotedState;
   } else if (data == "'") {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     currentDoctypeToken.systemId = "";
     state = doctypeSystemIdentifierSingleQuotedState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     currentDoctypeToken.correct = false;
     state = bogusDoctypeState;
   }
   return true;
 }

 bool betweenDoctypePublicAndSystemIdentifiersState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     return true;
   } else if (data == "&gt;") {
     _addToken(currentToken);
     state = dataState;
   } else if (data == '"') {
     currentDoctypeToken.systemId = "";
     state = doctypeSystemIdentifierDoubleQuotedState;
   } else if (data == "'") {
     currentDoctypeToken.systemId = "";
     state = doctypeSystemIdentifierSingleQuotedState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     currentDoctypeToken.correct = false;
     state = bogusDoctypeState;
   }
   return true;
 }

 bool afterDoctypeSystemKeywordState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     state = beforeDoctypeSystemIdentifierState;
   } else if (data == "'" || data == '"') {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     stream.unget(data);
     state = beforeDoctypeSystemIdentifierState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     stream.unget(data);
     state = beforeDoctypeSystemIdentifierState;
   }
   return true;
 }

 bool beforeDoctypeSystemIdentifierState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     return true;
   } else if (data == "\"") {
     currentDoctypeToken.systemId = "";
     state = doctypeSystemIdentifierDoubleQuotedState;
   } else if (data == "'") {
     currentDoctypeToken.systemId = "";
     state = doctypeSystemIdentifierSingleQuotedState;
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     currentDoctypeToken.correct = false;
     state = bogusDoctypeState;
   }
   return true;
 }

 bool doctypeSystemIdentifierDoubleQuotedState() {
   var data = stream.char();
   if (data == "\"") {
     state = afterDoctypeSystemIdentifierState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentDoctypeToken.systemId = "${currentDoctypeToken.systemId}\uFFFD";
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     currentDoctypeToken.systemId = '${currentDoctypeToken.systemId}$data';
   }
   return true;
 }

 bool doctypeSystemIdentifierSingleQuotedState() {
   var data = stream.char();
   if (data == "'") {
     state = afterDoctypeSystemIdentifierState;
   } else if (data == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     currentDoctypeToken.systemId = "${currentDoctypeToken.systemId}\uFFFD";
   } else if (data == "&gt;") {
     _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     currentDoctypeToken.systemId = '${currentDoctypeToken.systemId}$data';
   }
   return true;
 }

 bool afterDoctypeSystemIdentifierState() {
   var data = stream.char();
   if (isWhitespace(data)) {
     return true;
   } else if (data == "&gt;") {
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     _addToken(new ParseErrorToken("eof-in-doctype"));
     currentDoctypeToken.correct = false;
     _addToken(currentToken);
     state = dataState;
   } else {
     _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
     state = bogusDoctypeState;
   }
   return true;
 }

 bool bogusDoctypeState() {
   var data = stream.char();
   if (data == "&gt;") {
     _addToken(currentToken);
     state = dataState;
   } else if (data == EOF) {
     // XXX EMIT
     stream.unget(data);
     _addToken(currentToken);
     state = dataState;
   }
   return true;
 }

 bool cdataSectionState() {
   var data = [];
   int matchedEnd = 0;
   while (true) {
     var ch = stream.char();
     if (ch == EOF) {
       break;
     }
     // Deal with null here rather than in the parser
     if (ch == "\u0000") {
       _addToken(new ParseErrorToken("invalid-codepoint"));
       ch = "\uFFFD";
     }
     data.add(ch);
     // TODO(jmesserly): it'd be nice if we had an easier way to match the end,
     // perhaps with a "peek" API.
     if (ch == "]" &amp;&amp; matchedEnd &lt; 2) {
       matchedEnd++;
     } else if (ch == "&gt;" &amp;&amp; matchedEnd == 2) {
       // Remove "]]&gt;" from the end.
       data.removeLast();
       data.removeLast();
       data.removeLast();
       break;
     } else {
       matchedEnd = 0;
     }
   }

   if (data.length &gt; 0) {
     _addToken(new CharactersToken(data.join()));
   }
   state = dataState;
   return true;
 }
}
</pre>
</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="http://api.dartlang.org/dart_core/Iterator.html" ref="external">Iterator&lt;Token&gt;</a></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>HtmlTokenizer</strong>(doc, {<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> encoding, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> parseMeta: true, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> lowercaseElementName: true, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> lowercaseAttrName: true, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> generateSpans: false, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> sourceUrl, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> attributeSpans: false}) <a class="anchor-link" href="#"
              title="Permalink to HtmlTokenizer.HtmlTokenizer">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> </div></div>
<pre class="source">
HtmlTokenizer(doc, {String encoding, bool parseMeta: true,
   this.lowercaseElementName: true, this.lowercaseAttrName: true,
   bool generateSpans: false, String sourceUrl, this.attributeSpans: false})
   : stream = new HtmlInputStream(
         doc, encoding, parseMeta, generateSpans, sourceUrl),
     tokenQueue = new Queue(),
     generateSpans = generateSpans {
 reset();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="attributeSpans">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>attributeSpans</strong> <a class="anchor-link"
            href="#attributeSpans"
            title="Permalink to HtmlTokenizer.attributeSpans">#</a>
        </h4>
        <div class="doc">
<p>True to generate spans for attributes. </p>
<pre class="source">
final bool attributeSpans
</pre>
</div>
</div>
<div class="field"><h4 id="current">
<button class="show-code">Code</button>
final <a href="../token/Token.html">Token</a>         <strong>current</strong> <a class="anchor-link"
            href="#current"
            title="Permalink to HtmlTokenizer.current">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns the current element.</p>
<p>Return <code>null</code> if the iterator has not yet been moved to the first
element, or if the iterator has been moved after the last element of the
<a class="crossref" href="http://api.dartlang.org/dart_core/Iterable.html">Iterable</a>.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Iterator.html" ref="external">Iterator</a>&lt;<a href="../token/Token.html">Token</a>&gt; </div></div>
<pre class="source">
Token get current =&gt; _current;
</pre>
</div>
</div>
<div class="field"><h4 id="currentDoctypeToken">
<button class="show-code">Code</button>
final <a href="../token/DoctypeToken.html">DoctypeToken</a>         <strong>currentDoctypeToken</strong> <a class="anchor-link"
            href="#currentDoctypeToken"
            title="Permalink to HtmlTokenizer.currentDoctypeToken">#</a>
        </h4>
        <div class="doc">
<pre class="source">
DoctypeToken get currentDoctypeToken =&gt; currentToken;
</pre>
</div>
</div>
<div class="field"><h4 id="currentStringToken">
<button class="show-code">Code</button>
final <a href="../token/StringToken.html">StringToken</a>         <strong>currentStringToken</strong> <a class="anchor-link"
            href="#currentStringToken"
            title="Permalink to HtmlTokenizer.currentStringToken">#</a>
        </h4>
        <div class="doc">
<pre class="source">
StringToken get currentStringToken =&gt; currentToken;
</pre>
</div>
</div>
<div class="field"><h4 id="currentTagToken">
<button class="show-code">Code</button>
final <a href="../token/TagToken.html">TagToken</a>         <strong>currentTagToken</strong> <a class="anchor-link"
            href="#currentTagToken"
            title="Permalink to HtmlTokenizer.currentTagToken">#</a>
        </h4>
        <div class="doc">
<pre class="source">
TagToken get currentTagToken =&gt; currentToken;
</pre>
</div>
</div>
<div class="field"><h4 id="currentToken">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a>         <strong>currentToken</strong> <a class="anchor-link"
            href="#currentToken"
            title="Permalink to HtmlTokenizer.currentToken">#</a>
        </h4>
        <div class="doc">
<p>Holds the token that is currently being processed. </p>
<pre class="source">
Token currentToken
</pre>
</div>
</div>
<div class="field"><h4 id="generateSpans">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>generateSpans</strong> <a class="anchor-link"
            href="#generateSpans"
            title="Permalink to HtmlTokenizer.generateSpans">#</a>
        </h4>
        <div class="doc">
<p>True to generate spans in for <code>Token.span</code>. </p>
<pre class="source">
final bool generateSpans
</pre>
</div>
</div>
<div class="field"><h4 id="lowercaseAttrName">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>lowercaseAttrName</strong> <a class="anchor-link"
            href="#lowercaseAttrName"
            title="Permalink to HtmlTokenizer.lowercaseAttrName">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final bool lowercaseAttrName
</pre>
</div>
</div>
<div class="field"><h4 id="lowercaseElementName">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>lowercaseElementName</strong> <a class="anchor-link"
            href="#lowercaseElementName"
            title="Permalink to HtmlTokenizer.lowercaseElementName">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final bool lowercaseElementName
</pre>
</div>
</div>
<div class="field"><h4 id="parser">
<button class="show-code">Code</button>
<a href="../parser/HtmlParser.html">HtmlParser</a>         <strong>parser</strong> <a class="anchor-link"
            href="#parser"
            title="Permalink to HtmlTokenizer.parser">#</a>
        </h4>
        <div class="doc">
<p>This reference to the parser is used for correct CDATA handling.
The <a class="crossref" href="../parser/HtmlParser.html">HtmlParser</a> will set this at construction time.</p>
<pre class="source">
HtmlParser parser
</pre>
</div>
</div>
<div class="field"><h4 id="state">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html" ref="external">Function</a>         <strong>state</strong> <a class="anchor-link"
            href="#state"
            title="Permalink to HtmlTokenizer.state">#</a>
        </h4>
        <div class="doc">
<p>Holds a reference to the method to be invoked for the next parser state.</p>
<pre class="source">
Function state
</pre>
</div>
</div>
<div class="field"><h4 id="stream">
<button class="show-code">Code</button>
final <a href="../inputstream/HtmlInputStream.html">HtmlInputStream</a>         <strong>stream</strong> <a class="anchor-link"
            href="#stream"
            title="Permalink to HtmlTokenizer.stream">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final HtmlInputStream stream
</pre>
</div>
</div>
<div class="field"><h4 id="temporaryBuffer">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>temporaryBuffer</strong> <a class="anchor-link"
            href="#temporaryBuffer"
            title="Permalink to HtmlTokenizer.temporaryBuffer">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String temporaryBuffer
</pre>
</div>
</div>
<div class="field"><h4 id="tokenQueue">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_collection/Queue.html" ref="external">Queue</a>&lt;<a href="../token/Token.html">Token</a>&gt;         <strong>tokenQueue</strong> <a class="anchor-link"
            href="#tokenQueue"
            title="Permalink to HtmlTokenizer.tokenQueue">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final Queue&lt;Token&gt; tokenQueue
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="afterAttributeNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>afterAttributeNameState</strong>() <a class="anchor-link" href="#afterAttributeNameState"
              title="Permalink to HtmlTokenizer.afterAttributeNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool afterAttributeNameState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   stream.charsUntil(spaceCharacters, true);
 } else if (data == "=") {
   state = beforeAttributeValueState;
 } else if (data == "&gt;") {
   emitCurrentToken();
 } else if (isLetter(data)) {
   _addAttribute(data);
   state = attributeNameState;
 } else if (data == "/") {
   state = selfClosingStartTagState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addAttribute("\uFFFD");
   state = attributeNameState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("expected-end-of-tag-but-got-eof"));
   state = dataState;
 } else if ("'\"&lt;".contains(data)) {
   _addToken(new ParseErrorToken("invalid-character-after-attribute-name"));
   _addAttribute(data);
   state = attributeNameState;
 } else {
   _addAttribute(data);
   state = attributeNameState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="afterAttributeValueState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>afterAttributeValueState</strong>() <a class="anchor-link" href="#afterAttributeValueState"
              title="Permalink to HtmlTokenizer.afterAttributeValueState">#</a></h4>
<div class="doc">
<pre class="source">
bool afterAttributeValueState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   state = beforeAttributeNameState;
 } else if (data == "&gt;") {
   emitCurrentToken();
 } else if (data == "/") {
   state = selfClosingStartTagState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("unexpected-EOF-after-attribute-value"));
   stream.unget(data);
   state = dataState;
 } else {
   _addToken(new ParseErrorToken(
       "unexpected-character-after-attribute-value"));
   stream.unget(data);
   state = beforeAttributeNameState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="afterDoctypeNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>afterDoctypeNameState</strong>() <a class="anchor-link" href="#afterDoctypeNameState"
              title="Permalink to HtmlTokenizer.afterDoctypeNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool afterDoctypeNameState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   return true;
 } else if (data == "&gt;") {
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   currentDoctypeToken.correct = false;
   stream.unget(data);
   _addToken(new ParseErrorToken("eof-in-doctype"));
   _addToken(currentToken);
   state = dataState;
 } else {
   if (data == "p" || data == "P") {
     // TODO(jmesserly): would be nice to have a helper for this.
     var matched = true;
     for (var expected in const ["uU", "bB", "lL", "iI", "cC"]) {
       data = stream.char();
       if (data == EOF || !expected.contains(data)) {
         matched = false;
         break;
       }
     }
     if (matched) {
       state = afterDoctypePublicKeywordState;
       return true;
     }
   } else if (data == "s" || data == "S") {
     var matched = true;
     for (var expected in const ["yY", "sS", "tT", "eE", "mM"]) {
       data = stream.char();
       if (data == EOF || !expected.contains(data)) {
         matched = false;
         break;
       }
     }
     if (matched) {
       state = afterDoctypeSystemKeywordState;
       return true;
     }
   }

   // All the characters read before the current 'data' will be
   // [a-zA-Z], so they're garbage in the bogus doctype and can be
   // discarded; only the latest character might be '&gt;' or EOF
   // and needs to be ungetted
   stream.unget(data);
   _addToken(new ParseErrorToken(
       "expected-space-or-right-bracket-in-doctype",
       messageParams: {"data": data}));
   currentDoctypeToken.correct = false;
   state = bogusDoctypeState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="afterDoctypePublicIdentifierState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>afterDoctypePublicIdentifierState</strong>() <a class="anchor-link" href="#afterDoctypePublicIdentifierState"
              title="Permalink to HtmlTokenizer.afterDoctypePublicIdentifierState">#</a></h4>
<div class="doc">
<pre class="source">
bool afterDoctypePublicIdentifierState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   state = betweenDoctypePublicAndSystemIdentifiersState;
 } else if (data == "&gt;") {
   _addToken(currentToken);
   state = dataState;
 } else if (data == '"') {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   currentDoctypeToken.systemId = "";
   state = doctypeSystemIdentifierDoubleQuotedState;
 } else if (data == "'") {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   currentDoctypeToken.systemId = "";
   state = doctypeSystemIdentifierSingleQuotedState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   currentDoctypeToken.correct = false;
   state = bogusDoctypeState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="afterDoctypePublicKeywordState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>afterDoctypePublicKeywordState</strong>() <a class="anchor-link" href="#afterDoctypePublicKeywordState"
              title="Permalink to HtmlTokenizer.afterDoctypePublicKeywordState">#</a></h4>
<div class="doc">
<pre class="source">
bool afterDoctypePublicKeywordState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   state = beforeDoctypePublicIdentifierState;
 } else if (data == "'" || data == '"') {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   stream.unget(data);
   state = beforeDoctypePublicIdentifierState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   stream.unget(data);
   state = beforeDoctypePublicIdentifierState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="afterDoctypeSystemIdentifierState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>afterDoctypeSystemIdentifierState</strong>() <a class="anchor-link" href="#afterDoctypeSystemIdentifierState"
              title="Permalink to HtmlTokenizer.afterDoctypeSystemIdentifierState">#</a></h4>
<div class="doc">
<pre class="source">
bool afterDoctypeSystemIdentifierState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   return true;
 } else if (data == "&gt;") {
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   state = bogusDoctypeState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="afterDoctypeSystemKeywordState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>afterDoctypeSystemKeywordState</strong>() <a class="anchor-link" href="#afterDoctypeSystemKeywordState"
              title="Permalink to HtmlTokenizer.afterDoctypeSystemKeywordState">#</a></h4>
<div class="doc">
<pre class="source">
bool afterDoctypeSystemKeywordState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   state = beforeDoctypeSystemIdentifierState;
 } else if (data == "'" || data == '"') {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   stream.unget(data);
   state = beforeDoctypeSystemIdentifierState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   stream.unget(data);
   state = beforeDoctypeSystemIdentifierState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="attributeNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>attributeNameState</strong>() <a class="anchor-link" href="#attributeNameState"
              title="Permalink to HtmlTokenizer.attributeNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool attributeNameState() {
 var data = stream.char();
 bool leavingThisState = true;
 bool emitToken = false;
 if (data == "=") {
   state = beforeAttributeValueState;
 } else if (isLetter(data)) {
   _attributeName = '$_attributeName$data'
       '${stream.charsUntil(asciiLetters, true)}';
   leavingThisState = false;
 } else if (data == "&gt;") {
   // XXX If we emit here the attributes are converted to a dict
   // without being checked and when the code below runs we error
   // because data is a dict not a list
   emitToken = true;
 } else if (isWhitespace(data)) {
   state = afterAttributeNameState;
 } else if (data == "/") {
   state = selfClosingStartTagState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _attributeName = '${_attributeName}\uFFFD';
   leavingThisState = false;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-attribute-name"));
   state = dataState;
 } else if ("'\"&lt;".contains(data)) {
   _addToken(new ParseErrorToken("invalid-character-in-attribute-name"));
   _attributeName = '$_attributeName$data';
   leavingThisState = false;
 } else {
   _attributeName = '$_attributeName$data';
   leavingThisState = false;
 }

 if (leavingThisState) {
   _markAttributeNameEnd(-1);

   // Attributes are not dropped at this stage. That happens when the
   // start tag token is emitted so values can still be safely appended
   // to attributes, but we do want to report the parse error in time.
   if (lowercaseAttrName) {
     _attributeName = asciiUpper2Lower(_attributeName);
   }
   if (_attributeNames == null) _attributeNames = new Set();
   if (_attributeNames.contains(_attributeName)) {
     _addToken(new ParseErrorToken("duplicate-attribute"));
   }
   _attributeNames.add(_attributeName);

   // XXX Fix for above XXX
   if (emitToken) {
     emitCurrentToken();
   }
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="attributeValueDoubleQuotedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>attributeValueDoubleQuotedState</strong>() <a class="anchor-link" href="#attributeValueDoubleQuotedState"
              title="Permalink to HtmlTokenizer.attributeValueDoubleQuotedState">#</a></h4>
<div class="doc">
<pre class="source">
bool attributeValueDoubleQuotedState() {
 var data = stream.char();
 if (data == "\"") {
   _markAttributeValueEnd(-1);
   _markAttributeEnd(0);
   state = afterAttributeValueState;
 } else if (data == "&amp;") {
   processEntityInAttribute('"');
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _attributeValue = '${_attributeValue}\uFFFD';
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-attribute-value-double-quote"));
   _markAttributeValueEnd(-1);
   state = dataState;
 } else {
   _attributeValue = '$_attributeValue$data${stream.charsUntil("\"&amp;")}';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="attributeValueSingleQuotedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>attributeValueSingleQuotedState</strong>() <a class="anchor-link" href="#attributeValueSingleQuotedState"
              title="Permalink to HtmlTokenizer.attributeValueSingleQuotedState">#</a></h4>
<div class="doc">
<pre class="source">
bool attributeValueSingleQuotedState() {
 var data = stream.char();
 if (data == "'") {
   _markAttributeValueEnd(-1);
   _markAttributeEnd(0);
   state = afterAttributeValueState;
 } else if (data == "&amp;") {
   processEntityInAttribute("'");
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _attributeValue = '${_attributeValue}\uFFFD';
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-attribute-value-single-quote"));
   _markAttributeValueEnd(-1);
   state = dataState;
 } else {
   _attributeValue = '$_attributeValue$data${stream.charsUntil("\'&amp;")}';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="attributeValueUnQuotedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>attributeValueUnQuotedState</strong>() <a class="anchor-link" href="#attributeValueUnQuotedState"
              title="Permalink to HtmlTokenizer.attributeValueUnQuotedState">#</a></h4>
<div class="doc">
<pre class="source">
bool attributeValueUnQuotedState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   _markAttributeValueEnd(-1);
   state = beforeAttributeNameState;
 } else if (data == "&amp;") {
   processEntityInAttribute("&gt;");
 } else if (data == "&gt;") {
   _markAttributeValueEnd(-1);
   emitCurrentToken();
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-attribute-value-no-quotes"));
   _markAttributeValueEnd(-1);
   state = dataState;
 } else if ('"\'=&lt;`'.contains(data)) {
   _addToken(new ParseErrorToken(
       "unexpected-character-in-unquoted-attribute-value"));
   _attributeValue = '$_attributeValue$data';
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _attributeValue = '${_attributeValue}\uFFFD';
 } else {
   _attributeValue = '$_attributeValue$data'
       '${stream.charsUntil("&amp;&gt;\"\'=&lt;`$spaceCharacters")}';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="beforeAttributeNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>beforeAttributeNameState</strong>() <a class="anchor-link" href="#beforeAttributeNameState"
              title="Permalink to HtmlTokenizer.beforeAttributeNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool beforeAttributeNameState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   stream.charsUntil(spaceCharacters, true);
 } else if (isLetter(data)) {
   _addAttribute(data);
   state = attributeNameState;
 } else if (data == "&gt;") {
   emitCurrentToken();
 } else if (data == "/") {
   state = selfClosingStartTagState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("expected-attribute-name-but-got-eof"));
   state = dataState;
 } else if ("'\"=&lt;".contains(data)) {
   _addToken(new ParseErrorToken("invalid-character-in-attribute-name"));
   _addAttribute(data);
   state = attributeNameState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addAttribute("\uFFFD");
   state = attributeNameState;
 } else {
   _addAttribute(data);
   state = attributeNameState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="beforeAttributeValueState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>beforeAttributeValueState</strong>() <a class="anchor-link" href="#beforeAttributeValueState"
              title="Permalink to HtmlTokenizer.beforeAttributeValueState">#</a></h4>
<div class="doc">
<pre class="source">
bool beforeAttributeValueState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   stream.charsUntil(spaceCharacters, true);
 } else if (data == "\"") {
   _markAttributeValueStart(0);
   state = attributeValueDoubleQuotedState;
 } else if (data == "&amp;") {
   state = attributeValueUnQuotedState;
   stream.unget(data);
   _markAttributeValueStart(0);
 } else if (data == "'") {
   _markAttributeValueStart(0);
   state = attributeValueSingleQuotedState;
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken(
       "expected-attribute-value-but-got-right-bracket"));
   emitCurrentToken();
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _markAttributeValueStart(-1);
   _attributeValue = '${_attributeValue}\uFFFD';
   state = attributeValueUnQuotedState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("expected-attribute-value-but-got-eof"));
   state = dataState;
 } else if ("=&lt;`".contains(data)) {
   _addToken(new ParseErrorToken("equals-in-unquoted-attribute-value"));
   _markAttributeValueStart(-1);
   _attributeValue = '$_attributeValue$data';
   state = attributeValueUnQuotedState;
 } else {
   _markAttributeValueStart(-1);
   _attributeValue = '$_attributeValue$data';
   state = attributeValueUnQuotedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="beforeDoctypeNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>beforeDoctypeNameState</strong>() <a class="anchor-link" href="#beforeDoctypeNameState"
              title="Permalink to HtmlTokenizer.beforeDoctypeNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool beforeDoctypeNameState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   return true;
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken(
       "expected-doctype-name-but-got-right-bracket"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentDoctypeToken.name = "\uFFFD";
   state = doctypeNameState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken(
       "expected-doctype-name-but-got-eof"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   currentDoctypeToken.name = data;
   state = doctypeNameState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="beforeDoctypePublicIdentifierState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>beforeDoctypePublicIdentifierState</strong>() <a class="anchor-link" href="#beforeDoctypePublicIdentifierState"
              title="Permalink to HtmlTokenizer.beforeDoctypePublicIdentifierState">#</a></h4>
<div class="doc">
<pre class="source">
bool beforeDoctypePublicIdentifierState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   return true;
 } else if (data == "\"") {
   currentDoctypeToken.publicId = "";
   state = doctypePublicIdentifierDoubleQuotedState;
 } else if (data == "'") {
   currentDoctypeToken.publicId = "";
   state = doctypePublicIdentifierSingleQuotedState;
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   currentDoctypeToken.correct = false;
   state = bogusDoctypeState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="beforeDoctypeSystemIdentifierState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>beforeDoctypeSystemIdentifierState</strong>() <a class="anchor-link" href="#beforeDoctypeSystemIdentifierState"
              title="Permalink to HtmlTokenizer.beforeDoctypeSystemIdentifierState">#</a></h4>
<div class="doc">
<pre class="source">
bool beforeDoctypeSystemIdentifierState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   return true;
 } else if (data == "\"") {
   currentDoctypeToken.systemId = "";
   state = doctypeSystemIdentifierDoubleQuotedState;
 } else if (data == "'") {
   currentDoctypeToken.systemId = "";
   state = doctypeSystemIdentifierSingleQuotedState;
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   currentDoctypeToken.correct = false;
   state = bogusDoctypeState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="betweenDoctypePublicAndSystemIdentifiersState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>betweenDoctypePublicAndSystemIdentifiersState</strong>() <a class="anchor-link" href="#betweenDoctypePublicAndSystemIdentifiersState"
              title="Permalink to HtmlTokenizer.betweenDoctypePublicAndSystemIdentifiersState">#</a></h4>
<div class="doc">
<pre class="source">
bool betweenDoctypePublicAndSystemIdentifiersState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   return true;
 } else if (data == "&gt;") {
   _addToken(currentToken);
   state = dataState;
 } else if (data == '"') {
   currentDoctypeToken.systemId = "";
   state = doctypeSystemIdentifierDoubleQuotedState;
 } else if (data == "'") {
   currentDoctypeToken.systemId = "";
   state = doctypeSystemIdentifierSingleQuotedState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   _addToken(new ParseErrorToken("unexpected-char-in-doctype"));
   currentDoctypeToken.correct = false;
   state = bogusDoctypeState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="bogusCommentState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>bogusCommentState</strong>() <a class="anchor-link" href="#bogusCommentState"
              title="Permalink to HtmlTokenizer.bogusCommentState">#</a></h4>
<div class="doc">
<pre class="source">
bool bogusCommentState() {
 // Make a new comment token and give it as value all the characters
 // until the first &gt; or EOF (charsUntil checks for EOF automatically)
 // and emit it.
 var data = stream.charsUntil("&gt;");
 data = data.replaceAll("\u0000", "\uFFFD");
 _addToken(new CommentToken(data));

 // Eat the character directly after the bogus comment which is either a
 // "&gt;" or an EOF.
 stream.char();
 state = dataState;
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="bogusDoctypeState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>bogusDoctypeState</strong>() <a class="anchor-link" href="#bogusDoctypeState"
              title="Permalink to HtmlTokenizer.bogusDoctypeState">#</a></h4>
<div class="doc">
<pre class="source">
bool bogusDoctypeState() {
 var data = stream.char();
 if (data == "&gt;") {
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   // XXX EMIT
   stream.unget(data);
   _addToken(currentToken);
   state = dataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="cdataSectionState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>cdataSectionState</strong>() <a class="anchor-link" href="#cdataSectionState"
              title="Permalink to HtmlTokenizer.cdataSectionState">#</a></h4>
<div class="doc">
<pre class="source">
bool cdataSectionState() {
 var data = [];
 int matchedEnd = 0;
 while (true) {
   var ch = stream.char();
   if (ch == EOF) {
     break;
   }
   // Deal with null here rather than in the parser
   if (ch == "\u0000") {
     _addToken(new ParseErrorToken("invalid-codepoint"));
     ch = "\uFFFD";
   }
   data.add(ch);
   // TODO(jmesserly): it'd be nice if we had an easier way to match the end,
   // perhaps with a "peek" API.
   if (ch == "]" &amp;&amp; matchedEnd &lt; 2) {
     matchedEnd++;
   } else if (ch == "&gt;" &amp;&amp; matchedEnd == 2) {
     // Remove "]]&gt;" from the end.
     data.removeLast();
     data.removeLast();
     data.removeLast();
     break;
   } else {
     matchedEnd = 0;
   }
 }

 if (data.length &gt; 0) {
   _addToken(new CharactersToken(data.join()));
 }
 state = dataState;
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="characterReferenceInRcdata">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>characterReferenceInRcdata</strong>() <a class="anchor-link" href="#characterReferenceInRcdata"
              title="Permalink to HtmlTokenizer.characterReferenceInRcdata">#</a></h4>
<div class="doc">
<pre class="source">
bool characterReferenceInRcdata() {
 consumeEntity();
 state = rcdataState;
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="closeTagOpenState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>closeTagOpenState</strong>() <a class="anchor-link" href="#closeTagOpenState"
              title="Permalink to HtmlTokenizer.closeTagOpenState">#</a></h4>
<div class="doc">
<pre class="source">
bool closeTagOpenState() {
 var data = stream.char();
 if (isLetter(data)) {
   currentToken = new EndTagToken(data);
   state = tagNameState;
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken(
       "expected-closing-tag-but-got-right-bracket"));
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken(
       "expected-closing-tag-but-got-eof"));
   _addToken(new CharactersToken("&lt;/"));
   state = dataState;
 } else {
   // XXX data can be _'_...
   _addToken(new ParseErrorToken(
       "expected-closing-tag-but-got-char", messageParams: {"data": data}));
   stream.unget(data);
   state = bogusCommentState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="commentEndBangState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>commentEndBangState</strong>() <a class="anchor-link" href="#commentEndBangState"
              title="Permalink to HtmlTokenizer.commentEndBangState">#</a></h4>
<div class="doc">
<pre class="source">
bool commentEndBangState() {
 var data = stream.char();
 if (data == "&gt;") {
   _addToken(currentToken);
   state = dataState;
 } else if (data == "-") {
   currentStringToken.data = '${currentStringToken.data}--!';
   state = commentEndDashState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentStringToken.data = '${currentStringToken.data}--!\uFFFD';
   state = commentState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-comment-end-bang-state"));
   _addToken(currentToken);
   state = dataState;
 } else {
   currentStringToken.data = "${currentStringToken.data}--!${data}";
   state = commentState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="commentEndDashState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>commentEndDashState</strong>() <a class="anchor-link" href="#commentEndDashState"
              title="Permalink to HtmlTokenizer.commentEndDashState">#</a></h4>
<div class="doc">
<pre class="source">
bool commentEndDashState() {
 var data = stream.char();
 if (data == "-") {
   state = commentEndState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentStringToken.data = "${currentStringToken.data}-\uFFFD";
   state = commentState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-comment-end-dash"));
   _addToken(currentToken);
   state = dataState;
 } else {
   currentStringToken.data = "${currentStringToken.data}-${data}";
   state = commentState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="commentEndState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>commentEndState</strong>() <a class="anchor-link" href="#commentEndState"
              title="Permalink to HtmlTokenizer.commentEndState">#</a></h4>
<div class="doc">
<pre class="source">
bool commentEndState() {
 var data = stream.char();
 if (data == "&gt;") {
   _addToken(currentToken);
   state = dataState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentStringToken.data = '${currentStringToken.data}--\uFFFD';
   state = commentState;
 } else if (data == "!") {
   _addToken(new ParseErrorToken(
       "unexpected-bang-after-double-dash-in-comment"));
   state = commentEndBangState;
 } else if (data == "-") {
   _addToken(new ParseErrorToken(
       "unexpected-dash-after-double-dash-in-comment"));
   currentStringToken.data = '${currentStringToken.data}$data';
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-comment-double-dash"));
   _addToken(currentToken);
   state = dataState;
 } else {
   // XXX
   _addToken(new ParseErrorToken("unexpected-char-in-comment"));
   currentStringToken.data = "${currentStringToken.data}--${data}";
   state = commentState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="commentStartDashState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>commentStartDashState</strong>() <a class="anchor-link" href="#commentStartDashState"
              title="Permalink to HtmlTokenizer.commentStartDashState">#</a></h4>
<div class="doc">
<pre class="source">
bool commentStartDashState() {
 var data = stream.char();
 if (data == "-") {
   state = commentEndState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentStringToken.data = '${currentStringToken.data}-\uFFFD';
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken("incorrect-comment"));
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-comment"));
   _addToken(currentToken);
   state = dataState;
 } else {
   currentStringToken.data = '${currentStringToken.data}-${data}';
   state = commentState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="commentStartState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>commentStartState</strong>() <a class="anchor-link" href="#commentStartState"
              title="Permalink to HtmlTokenizer.commentStartState">#</a></h4>
<div class="doc">
<pre class="source">
bool commentStartState() {
 var data = stream.char();
 if (data == "-") {
   state = commentStartDashState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentStringToken.data = '${currentStringToken.data}\uFFFD';
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken("incorrect-comment"));
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-comment"));
   _addToken(currentToken);
   state = dataState;
 } else {
   currentStringToken.data = '${currentStringToken.data}$data';
   state = commentState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="commentState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>commentState</strong>() <a class="anchor-link" href="#commentState"
              title="Permalink to HtmlTokenizer.commentState">#</a></h4>
<div class="doc">
<pre class="source">
bool commentState() {
 var data = stream.char();
 if (data == "-") {
   state = commentEndDashState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentStringToken.data = '${currentStringToken.data}\uFFFD';
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-comment"));
   _addToken(currentToken);
   state = dataState;
 } else {
   currentStringToken.data = '${currentStringToken.data}$data'
       '${stream.charsUntil("-\u0000")}';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="consumeEntity">
<button class="show-code">Code</button>
void <strong>consumeEntity</strong>({<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> allowedChar, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> fromAttribute: false}) <a class="anchor-link" href="#consumeEntity"
              title="Permalink to HtmlTokenizer.consumeEntity">#</a></h4>
<div class="doc">
<pre class="source">
void consumeEntity({String allowedChar, bool fromAttribute: false}) {
 // Initialise to the default output for when no entity is matched
 var output = "&amp;";

 var charStack = [stream.char()];
 if (isWhitespace(charStack[0]) || charStack[0] == '&lt;' || charStack[0] == '&amp;'
     || charStack[0] == EOF || allowedChar == charStack[0]) {
   stream.unget(charStack[0]);
 } else if (charStack[0] == "#") {
   // Read the next character to see if it's hex or decimal
   bool hex = false;
   charStack.add(stream.char());
   if (charStack.last == 'x' || charStack.last == 'X') {
     hex = true;
     charStack.add(stream.char());
   }

   // charStack.last should be the first digit
   if (hex &amp;&amp; isHexDigit(charStack.last) ||
       (!hex &amp;&amp; isDigit(charStack.last))) {
     // At least one digit found, so consume the whole number
     stream.unget(charStack.last);
     output = consumeNumberEntity(hex);
   } else {
     // No digits found
     _addToken(new ParseErrorToken("expected-numeric-entity"));
     stream.unget(charStack.removeLast());
     output = "&amp;${charStack.join()}";
   }
 } else {
   // At this point in the process might have named entity. Entities
   // are stored in the global variable "entities".
   //
   // Consume characters and compare to these to a substring of the
   // entity names in the list until the substring no longer matches.
   var filteredEntityList = entitiesByFirstChar[charStack[0]];
   if (filteredEntityList == null) filteredEntityList = const [];

   while (charStack.last != EOF) {
     var name = charStack.join();
     filteredEntityList = filteredEntityList.where(
         (e) =&gt; e.startsWith(name)).toList();

     if (filteredEntityList.length == 0) {
       break;
     }
     charStack.add(stream.char());
   }

   // At this point we have a string that starts with some characters
   // that may match an entity
   String entityName = null;

   // Try to find the longest entity the string will match to take care
   // of &amp;noti for instance.

   int entityLen;
   for (entityLen = charStack.length - 1; entityLen &gt; 1; entityLen--) {
     var possibleEntityName = charStack.sublist(0, entityLen).join();
     if (entities.containsKey(possibleEntityName)) {
       entityName = possibleEntityName;
       break;
     }
   }

   if (entityName != null) {
     var lastChar = entityName[entityName.length - 1];
     if (lastChar != ";") {
       _addToken(new ParseErrorToken(
           "named-entity-without-semicolon"));
     }
     if (lastChar != ";" &amp;&amp; fromAttribute &amp;&amp;
         (isLetterOrDigit(charStack[entityLen]) ||
          charStack[entityLen] == '=')) {
       stream.unget(charStack.removeLast());
       output = "&amp;${charStack.join()}";
     } else {
       output = entities[entityName];
       stream.unget(charStack.removeLast());
       output = '${output}${slice(charStack, entityLen).join()}';
     }
   } else {
     _addToken(new ParseErrorToken("expected-named-entity"));
     stream.unget(charStack.removeLast());
     output = "&amp;${charStack.join()}";
   }
 }
 if (fromAttribute) {
   _attributeValue = '$_attributeValue$output';
 } else {
   var token;
   if (isWhitespace(output)) {
     token = new SpaceCharactersToken(output);
   } else {
     token = new CharactersToken(output);
   }
   _addToken(token);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="consumeNumberEntity">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>consumeNumberEntity</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> isHex) <a class="anchor-link" href="#consumeNumberEntity"
              title="Permalink to HtmlTokenizer.consumeNumberEntity">#</a></h4>
<div class="doc">
<p>This function returns either U+FFFD or the character based on the
decimal or hexadecimal representation. It also discards ";" if present.
If not present it will add a <a class="crossref" href="../token/ParseErrorToken.html">ParseErrorToken</a>.</p>
<pre class="source">
String consumeNumberEntity(bool isHex) {
 var allowed = isDigit;
 var radix = 10;
 if (isHex) {
   allowed = isHexDigit;
   radix = 16;
 }

 var charStack = [];

 // Consume all the characters that are in range while making sure we
 // don't hit an EOF.
 var c = stream.char();
 while (allowed(c) &amp;&amp; c != EOF) {
   charStack.add(c);
   c = stream.char();
 }

 // Convert the set of characters consumed to an int.
 var charAsInt = parseIntRadix(charStack.join(), radix);

 // Certain characters get replaced with others
 var char = replacementCharacters[charAsInt];
 if (char != null) {
   _addToken(new ParseErrorToken(
       "illegal-codepoint-for-numeric-entity",
       messageParams: {"charAsInt": charAsInt}));
 } else if ((0xD800 &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0xDFFF)
     || (charAsInt &gt; 0x10FFFF)) {
   char = "\uFFFD";
   _addToken(new ParseErrorToken(
       "illegal-codepoint-for-numeric-entity",
       messageParams: {"charAsInt": charAsInt}));
 } else {
   // Should speed up this check somehow (e.g. move the set to a constant)
   if ((0x0001 &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0x0008) ||
       (0x000E &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0x001F) ||
       (0x007F &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0x009F) ||
       (0xFDD0 &lt;= charAsInt &amp;&amp; charAsInt &lt;= 0xFDEF) ||
       const [0x000B, 0xFFFE, 0xFFFF, 0x1FFFE,
             0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE,
             0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE,
             0x5FFFF, 0x6FFFE, 0x6FFFF, 0x7FFFE,
             0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE,
             0x9FFFF, 0xAFFFE, 0xAFFFF, 0xBFFFE,
             0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE,
             0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE,
             0xFFFFF, 0x10FFFE, 0x10FFFF].contains(charAsInt)) {
     _addToken(new ParseErrorToken(
         "illegal-codepoint-for-numeric-entity",
         messageParams: {"charAsInt": charAsInt}));
   }
   char = new String.fromCharCodes([charAsInt]);
 }

 // Discard the ; if present. Otherwise, put it back on the queue and
 // invoke parseError on parser.
 if (c != ";") {
   _addToken(new ParseErrorToken(
       "numeric-entity-without-semicolon"));
   stream.unget(c);
 }
 return char;
}
</pre>
</div>
</div>
<div class="method"><h4 id="dataState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>dataState</strong>() <a class="anchor-link" href="#dataState"
              title="Permalink to HtmlTokenizer.dataState">#</a></h4>
<div class="doc">
<pre class="source">
bool dataState() {
 var data = stream.char();
 if (data == "&amp;") {
   state = entityDataState;
 } else if (data == "&lt;") {
   state = tagOpenState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\u0000"));
 } else if (data == EOF) {
   // Tokenization ends.
   return false;
 } else if (isWhitespace(data)) {
   // Directly after emitting a token you switch back to the "data
   // state". At that point spaceCharacters are important so they are
   // emitted separately.
   _addToken(new SpaceCharactersToken(
       '${data}${stream.charsUntil(spaceCharacters, true)}'));
   // No need to update lastFourChars here, since the first space will
   // have already been appended to lastFourChars and will have broken
   // any &lt;!-- or --&gt; sequences
 } else {
   var chars = stream.charsUntil("&amp;&lt;\u0000");
   _addToken(new CharactersToken('${data}${chars}'));
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="doctypeNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>doctypeNameState</strong>() <a class="anchor-link" href="#doctypeNameState"
              title="Permalink to HtmlTokenizer.doctypeNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool doctypeNameState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   currentDoctypeToken.name = asciiUpper2Lower(currentDoctypeToken.name);
   state = afterDoctypeNameState;
 } else if (data == "&gt;") {
   currentDoctypeToken.name = asciiUpper2Lower(currentDoctypeToken.name);
   _addToken(currentToken);
   state = dataState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentDoctypeToken.name = "${currentDoctypeToken.name}\uFFFD";
   state = doctypeNameState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype-name"));
   currentDoctypeToken.correct = false;
   currentDoctypeToken.name = asciiUpper2Lower(currentDoctypeToken.name);
   _addToken(currentToken);
   state = dataState;
 } else {
   currentDoctypeToken.name = '${currentDoctypeToken.name}$data';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="doctypePublicIdentifierDoubleQuotedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>doctypePublicIdentifierDoubleQuotedState</strong>() <a class="anchor-link" href="#doctypePublicIdentifierDoubleQuotedState"
              title="Permalink to HtmlTokenizer.doctypePublicIdentifierDoubleQuotedState">#</a></h4>
<div class="doc">
<pre class="source">
bool doctypePublicIdentifierDoubleQuotedState() {
 var data = stream.char();
 if (data == '"') {
   state = afterDoctypePublicIdentifierState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentDoctypeToken.publicId = "${currentDoctypeToken.publicId}\uFFFD";
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   currentDoctypeToken.publicId = '${currentDoctypeToken.publicId}$data';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="doctypePublicIdentifierSingleQuotedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>doctypePublicIdentifierSingleQuotedState</strong>() <a class="anchor-link" href="#doctypePublicIdentifierSingleQuotedState"
              title="Permalink to HtmlTokenizer.doctypePublicIdentifierSingleQuotedState">#</a></h4>
<div class="doc">
<pre class="source">
bool doctypePublicIdentifierSingleQuotedState() {
 var data = stream.char();
 if (data == "'") {
   state = afterDoctypePublicIdentifierState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentDoctypeToken.publicId = "${currentDoctypeToken.publicId}\uFFFD";
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   currentDoctypeToken.publicId = '${currentDoctypeToken.publicId}$data';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="doctypeState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>doctypeState</strong>() <a class="anchor-link" href="#doctypeState"
              title="Permalink to HtmlTokenizer.doctypeState">#</a></h4>
<div class="doc">
<pre class="source">
bool doctypeState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   state = beforeDoctypeNameState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken(
       "expected-doctype-name-but-got-eof"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   _addToken(new ParseErrorToken("need-space-after-doctype"));
   stream.unget(data);
   state = beforeDoctypeNameState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="doctypeSystemIdentifierDoubleQuotedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>doctypeSystemIdentifierDoubleQuotedState</strong>() <a class="anchor-link" href="#doctypeSystemIdentifierDoubleQuotedState"
              title="Permalink to HtmlTokenizer.doctypeSystemIdentifierDoubleQuotedState">#</a></h4>
<div class="doc">
<pre class="source">
bool doctypeSystemIdentifierDoubleQuotedState() {
 var data = stream.char();
 if (data == "\"") {
   state = afterDoctypeSystemIdentifierState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentDoctypeToken.systemId = "${currentDoctypeToken.systemId}\uFFFD";
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   currentDoctypeToken.systemId = '${currentDoctypeToken.systemId}$data';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="doctypeSystemIdentifierSingleQuotedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>doctypeSystemIdentifierSingleQuotedState</strong>() <a class="anchor-link" href="#doctypeSystemIdentifierSingleQuotedState"
              title="Permalink to HtmlTokenizer.doctypeSystemIdentifierSingleQuotedState">#</a></h4>
<div class="doc">
<pre class="source">
bool doctypeSystemIdentifierSingleQuotedState() {
 var data = stream.char();
 if (data == "'") {
   state = afterDoctypeSystemIdentifierState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentDoctypeToken.systemId = "${currentDoctypeToken.systemId}\uFFFD";
 } else if (data == "&gt;") {
   _addToken(new ParseErrorToken("unexpected-end-of-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-doctype"));
   currentDoctypeToken.correct = false;
   _addToken(currentToken);
   state = dataState;
 } else {
   currentDoctypeToken.systemId = '${currentDoctypeToken.systemId}$data';
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="emitCurrentToken">
<button class="show-code">Code</button>
void <strong>emitCurrentToken</strong>() <a class="anchor-link" href="#emitCurrentToken"
              title="Permalink to HtmlTokenizer.emitCurrentToken">#</a></h4>
<div class="doc">
<p>This method is a generic handler for emitting the tags. It also sets
the state to "data" because that's what's needed after a token has been
emitted.</p>
<pre class="source">
void emitCurrentToken() {
 var token = currentToken;
 // Add token to the queue to be yielded
 if (token is TagToken) {
   if (lowercaseElementName) {
     token.name = asciiUpper2Lower(token.name);
   }
   if (token is EndTagToken) {
     if (_attributes != null) {
       _addToken(new ParseErrorToken("attributes-in-end-tag"));
     }
     if (token.selfClosing) {
       _addToken(new ParseErrorToken("this-closing-flag-on-end-tag"));
     }
   } else if (token is StartTagToken) {
     // HTML5 specific normalizations to the token stream.
     // Convert the list into a map where first key wins.
     token.data = new LinkedHashMap&lt;Object, String&gt;();
     if (_attributes != null) {
       for (var attr in _attributes) {
         token.data.putIfAbsent(attr.name, () =&gt; attr.value);
       }
       if (attributeSpans) token.attributeSpans = _attributes;
     }
   }
   _attributes = null;
   _attributeNames = null;
 }
 _addToken(token);
 state = dataState;
}
</pre>
</div>
</div>
<div class="method"><h4 id="entityDataState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>entityDataState</strong>() <a class="anchor-link" href="#entityDataState"
              title="Permalink to HtmlTokenizer.entityDataState">#</a></h4>
<div class="doc">
<pre class="source">
bool entityDataState() {
 consumeEntity();
 state = dataState;
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="markupDeclarationOpenState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>markupDeclarationOpenState</strong>() <a class="anchor-link" href="#markupDeclarationOpenState"
              title="Permalink to HtmlTokenizer.markupDeclarationOpenState">#</a></h4>
<div class="doc">
<pre class="source">
bool markupDeclarationOpenState() {
 var charStack = [stream.char()];
 if (charStack.last == "-") {
   charStack.add(stream.char());
   if (charStack.last == "-") {
     currentToken = new CommentToken("");
     state = commentStartState;
     return true;
   }
 } else if (charStack.last == 'd' || charStack.last == 'D') {
   var matched = true;
   for (var expected in const ['oO', 'cC', 'tT', 'yY', 'pP', 'eE']) {
     var char = stream.char();
     charStack.add(char);
     if (char == EOF || !expected.contains(char)) {
       matched = false;
       break;
     }
   }
   if (matched) {
     currentToken = new DoctypeToken(correct: true);
     state = doctypeState;
     return true;
   }
 } else if (charStack.last == "[" &amp;&amp;
     parser != null &amp;&amp; parser.tree.openElements.length &gt; 0 &amp;&amp;
     parser.tree.openElements.last.namespace
         != parser.tree.defaultNamespace) {
   var matched = true;
   for (var expected in const ["C", "D", "A", "T", "A", "["]) {
     charStack.add(stream.char());
     if (charStack.last != expected) {
       matched = false;
       break;
     }
   }
   if (matched) {
     state = cdataSectionState;
     return true;
   }
 }

 _addToken(new ParseErrorToken("expected-dashes-or-doctype"));

 while (charStack.length &gt; 0) {
   stream.unget(charStack.removeLast());
 }
 state = bogusCommentState;
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="moveNext">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>moveNext</strong>() <a class="anchor-link" href="#moveNext"
              title="Permalink to HtmlTokenizer.moveNext">#</a></h4>
<div class="doc">
<p>This is where the magic happens.</p>
<p>We do our usually processing through the states and when we have a token
to return we yield the token which pauses processing until the next token
is requested.</p>
<pre class="source">
bool moveNext() {
 // Start processing. When EOF is reached state will return false;
 // instead of true and the loop will terminate.
 while (stream.errors.length == 0 &amp;&amp; tokenQueue.length == 0) {
   if (!state()) {
     _current = null;
     return false;
   }
 }
 if (stream.errors.length &gt; 0) {
   _current = new ParseErrorToken(stream.errors.removeFirst());
 } else {
   assert (tokenQueue.length &gt; 0);
   _current = tokenQueue.removeFirst();
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="plaintextState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>plaintextState</strong>() <a class="anchor-link" href="#plaintextState"
              title="Permalink to HtmlTokenizer.plaintextState">#</a></h4>
<div class="doc">
<pre class="source">
bool plaintextState() {
 var data = stream.char();
 if (data == EOF) {
   // Tokenization ends.
   return false;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
 } else {
   _addToken(new CharactersToken(
       '${data}${stream.charsUntil("\u0000")}'));
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="processEntityInAttribute">
<button class="show-code">Code</button>
void <strong>processEntityInAttribute</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> allowedChar) <a class="anchor-link" href="#processEntityInAttribute"
              title="Permalink to HtmlTokenizer.processEntityInAttribute">#</a></h4>
<div class="doc">
<p>This method replaces the need for "entityInAttributeValueState". </p>
<pre class="source">
void processEntityInAttribute(String allowedChar) {
 consumeEntity(allowedChar: allowedChar, fromAttribute: true);
}
</pre>
</div>
</div>
<div class="method"><h4 id="rawtextEndTagNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>rawtextEndTagNameState</strong>() <a class="anchor-link" href="#rawtextEndTagNameState"
              title="Permalink to HtmlTokenizer.rawtextEndTagNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool rawtextEndTagNameState() {
 var appropriate = _tokenIsAppropriate();
 var data = stream.char();
 if (isWhitespace(data) &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   state = beforeAttributeNameState;
 } else if (data == "/" &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   state = selfClosingStartTagState;
 } else if (data == "&gt;" &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   emitCurrentToken();
   state = dataState;
 } else if (isLetter(data)) {
   temporaryBuffer = '${temporaryBuffer}$data';
 } else {
   _addToken(new CharactersToken("&lt;/$temporaryBuffer"));
   stream.unget(data);
   state = rawtextState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="rawtextEndTagOpenState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>rawtextEndTagOpenState</strong>() <a class="anchor-link" href="#rawtextEndTagOpenState"
              title="Permalink to HtmlTokenizer.rawtextEndTagOpenState">#</a></h4>
<div class="doc">
<pre class="source">
bool rawtextEndTagOpenState() {
 var data = stream.char();
 if (isLetter(data)) {
   temporaryBuffer = '${temporaryBuffer}$data';
   state = rawtextEndTagNameState;
 } else {
   _addToken(new CharactersToken("&lt;/"));
   stream.unget(data);
   state = rawtextState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="rawtextLessThanSignState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>rawtextLessThanSignState</strong>() <a class="anchor-link" href="#rawtextLessThanSignState"
              title="Permalink to HtmlTokenizer.rawtextLessThanSignState">#</a></h4>
<div class="doc">
<pre class="source">
bool rawtextLessThanSignState() {
 var data = stream.char();
 if (data == "/") {
   temporaryBuffer = "";
   state = rawtextEndTagOpenState;
 } else {
   _addToken(new CharactersToken("&lt;"));
   stream.unget(data);
   state = rawtextState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="rawtextState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>rawtextState</strong>() <a class="anchor-link" href="#rawtextState"
              title="Permalink to HtmlTokenizer.rawtextState">#</a></h4>
<div class="doc">
<pre class="source">
bool rawtextState() {
 var data = stream.char();
 if (data == "&lt;") {
   state = rawtextLessThanSignState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
 } else if (data == EOF) {
   // Tokenization ends.
   return false;
 } else {
   var chars = stream.charsUntil("&lt;\u0000");
   _addToken(new CharactersToken("${data}${chars}"));
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="rcdataEndTagNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>rcdataEndTagNameState</strong>() <a class="anchor-link" href="#rcdataEndTagNameState"
              title="Permalink to HtmlTokenizer.rcdataEndTagNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool rcdataEndTagNameState() {
 var appropriate = _tokenIsAppropriate();
 var data = stream.char();
 if (isWhitespace(data) &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   state = beforeAttributeNameState;
 } else if (data == "/" &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   state = selfClosingStartTagState;
 } else if (data == "&gt;" &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   emitCurrentToken();
   state = dataState;
 } else if (isLetter(data)) {
   temporaryBuffer = '${temporaryBuffer}$data';
 } else {
   _addToken(new CharactersToken("&lt;/$temporaryBuffer"));
   stream.unget(data);
   state = rcdataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="rcdataEndTagOpenState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>rcdataEndTagOpenState</strong>() <a class="anchor-link" href="#rcdataEndTagOpenState"
              title="Permalink to HtmlTokenizer.rcdataEndTagOpenState">#</a></h4>
<div class="doc">
<pre class="source">
bool rcdataEndTagOpenState() {
 var data = stream.char();
 if (isLetter(data)) {
   temporaryBuffer = '${temporaryBuffer}$data';
   state = rcdataEndTagNameState;
 } else {
   _addToken(new CharactersToken("&lt;/"));
   stream.unget(data);
   state = rcdataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="rcdataLessThanSignState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>rcdataLessThanSignState</strong>() <a class="anchor-link" href="#rcdataLessThanSignState"
              title="Permalink to HtmlTokenizer.rcdataLessThanSignState">#</a></h4>
<div class="doc">
<pre class="source">
bool rcdataLessThanSignState() {
 var data = stream.char();
 if (data == "/") {
   temporaryBuffer = "";
   state = rcdataEndTagOpenState;
 } else {
   _addToken(new CharactersToken("&lt;"));
   stream.unget(data);
   state = rcdataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="rcdataState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>rcdataState</strong>() <a class="anchor-link" href="#rcdataState"
              title="Permalink to HtmlTokenizer.rcdataState">#</a></h4>
<div class="doc">
<pre class="source">
bool rcdataState() {
 var data = stream.char();
 if (data == "&amp;") {
   state = characterReferenceInRcdata;
 } else if (data == "&lt;") {
   state = rcdataLessThanSignState;
 } else if (data == EOF) {
   // Tokenization ends.
   return false;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
 } else if (isWhitespace(data)) {
   // Directly after emitting a token you switch back to the "data
   // state". At that point spaceCharacters are important so they are
   // emitted separately.
   _addToken(new SpaceCharactersToken(
       '${data}${stream.charsUntil(spaceCharacters, true)}'));
 } else {
   var chars = stream.charsUntil("&amp;&lt;");
   _addToken(new CharactersToken('${data}${chars}'));
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="reset">
<button class="show-code">Code</button>
void <strong>reset</strong>() <a class="anchor-link" href="#reset"
              title="Permalink to HtmlTokenizer.reset">#</a></h4>
<div class="doc">
<p>Resets the tokenizer state. Calling this does not reset the <a class="crossref" href="../tokenizer/HtmlTokenizer.html#stream">stream</a> or
the <a class="crossref" href="../tokenizer/HtmlTokenizer.html#parser">parser</a>.</p>
<pre class="source">
void reset() {
 _lastOffset = 0;
 tokenQueue.clear();
 currentToken = null;
 temporaryBuffer = null;
 _attributes = null;
 _attributeNames = null;
 state = dataState;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataDoubleEscapedDashDashState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataDoubleEscapedDashDashState</strong>() <a class="anchor-link" href="#scriptDataDoubleEscapedDashDashState"
              title="Permalink to HtmlTokenizer.scriptDataDoubleEscapedDashDashState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataDoubleEscapedDashDashState() {
 var data = stream.char();
 if (data == "-") {
   _addToken(new CharactersToken("-"));
 } else if (data == "&lt;") {
   _addToken(new CharactersToken("&lt;"));
   state = scriptDataDoubleEscapedLessThanSignState;
 } else if (data == "&gt;") {
   _addToken(new CharactersToken("&gt;"));
   state = scriptDataState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
   state = scriptDataDoubleEscapedState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-script-in-script"));
   state = dataState;
 } else {
   _addToken(new CharactersToken(data));
   state = scriptDataDoubleEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataDoubleEscapedDashState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataDoubleEscapedDashState</strong>() <a class="anchor-link" href="#scriptDataDoubleEscapedDashState"
              title="Permalink to HtmlTokenizer.scriptDataDoubleEscapedDashState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataDoubleEscapedDashState() {
 var data = stream.char();
 if (data == "-") {
   _addToken(new CharactersToken("-"));
   state = scriptDataDoubleEscapedDashDashState;
 } else if (data == "&lt;") {
   _addToken(new CharactersToken("&lt;"));
   state = scriptDataDoubleEscapedLessThanSignState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
   state = scriptDataDoubleEscapedState;
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-script-in-script"));
   state = dataState;
 } else {
   _addToken(new CharactersToken(data));
   state = scriptDataDoubleEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataDoubleEscapedLessThanSignState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataDoubleEscapedLessThanSignState</strong>() <a class="anchor-link" href="#scriptDataDoubleEscapedLessThanSignState"
              title="Permalink to HtmlTokenizer.scriptDataDoubleEscapedLessThanSignState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataDoubleEscapedLessThanSignState() {
 var data = stream.char();
 if (data == "/") {
   _addToken(new CharactersToken("/"));
   temporaryBuffer = "";
   state = scriptDataDoubleEscapeEndState;
 } else {
   stream.unget(data);
   state = scriptDataDoubleEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataDoubleEscapedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataDoubleEscapedState</strong>() <a class="anchor-link" href="#scriptDataDoubleEscapedState"
              title="Permalink to HtmlTokenizer.scriptDataDoubleEscapedState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataDoubleEscapedState() {
 var data = stream.char();
 if (data == "-") {
   _addToken(new CharactersToken("-"));
   state = scriptDataDoubleEscapedDashState;
 } else if (data == "&lt;") {
   _addToken(new CharactersToken("&lt;"));
   state = scriptDataDoubleEscapedLessThanSignState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-script-in-script"));
   state = dataState;
 } else {
   _addToken(new CharactersToken(data));
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataDoubleEscapeEndState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataDoubleEscapeEndState</strong>() <a class="anchor-link" href="#scriptDataDoubleEscapeEndState"
              title="Permalink to HtmlTokenizer.scriptDataDoubleEscapeEndState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataDoubleEscapeEndState() {
 var data = stream.char();
 if (isWhitespace(data) || data == "/" || data == "&gt;") {
   _addToken(new CharactersToken(data));
   if (temporaryBuffer.toLowerCase() == "script") {
     state = scriptDataEscapedState;
   } else {
     state = scriptDataDoubleEscapedState;
   }
 } else if (isLetter(data)) {
   _addToken(new CharactersToken(data));
   temporaryBuffer = '${temporaryBuffer}$data';
 } else {
   stream.unget(data);
   state = scriptDataDoubleEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataDoubleEscapeStartState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataDoubleEscapeStartState</strong>() <a class="anchor-link" href="#scriptDataDoubleEscapeStartState"
              title="Permalink to HtmlTokenizer.scriptDataDoubleEscapeStartState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataDoubleEscapeStartState() {
 var data = stream.char();
 if (isWhitespace(data) || data == "/" || data == "&gt;") {
   _addToken(new CharactersToken(data));
   if (temporaryBuffer.toLowerCase() == "script") {
     state = scriptDataDoubleEscapedState;
   } else {
     state = scriptDataEscapedState;
   }
 } else if (isLetter(data)) {
   _addToken(new CharactersToken(data));
   temporaryBuffer = '${temporaryBuffer}$data';
 } else {
   stream.unget(data);
   state = scriptDataEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEndTagNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEndTagNameState</strong>() <a class="anchor-link" href="#scriptDataEndTagNameState"
              title="Permalink to HtmlTokenizer.scriptDataEndTagNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEndTagNameState() {
 var appropriate = _tokenIsAppropriate();
 var data = stream.char();
 if (isWhitespace(data) &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   state = beforeAttributeNameState;
 } else if (data == "/" &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   state = selfClosingStartTagState;
 } else if (data == "&gt;" &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   emitCurrentToken();
   state = dataState;
 } else if (isLetter(data)) {
   temporaryBuffer = '${temporaryBuffer}$data';
 } else {
   _addToken(new CharactersToken("&lt;/$temporaryBuffer"));
   stream.unget(data);
   state = scriptDataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEndTagOpenState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEndTagOpenState</strong>() <a class="anchor-link" href="#scriptDataEndTagOpenState"
              title="Permalink to HtmlTokenizer.scriptDataEndTagOpenState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEndTagOpenState() {
 var data = stream.char();
 if (isLetter(data)) {
   temporaryBuffer = '${temporaryBuffer}$data';
   state = scriptDataEndTagNameState;
 } else {
   _addToken(new CharactersToken("&lt;/"));
   stream.unget(data);
   state = scriptDataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEscapedDashDashState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEscapedDashDashState</strong>() <a class="anchor-link" href="#scriptDataEscapedDashDashState"
              title="Permalink to HtmlTokenizer.scriptDataEscapedDashDashState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEscapedDashDashState() {
 var data = stream.char();
 if (data == "-") {
   _addToken(new CharactersToken("-"));
 } else if (data == "&lt;") {
   state = scriptDataEscapedLessThanSignState;
 } else if (data == "&gt;") {
   _addToken(new CharactersToken("&gt;"));
   state = scriptDataState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
   state = scriptDataEscapedState;
 } else if (data == EOF) {
   state = dataState;
 } else {
   _addToken(new CharactersToken(data));
   state = scriptDataEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEscapedDashState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEscapedDashState</strong>() <a class="anchor-link" href="#scriptDataEscapedDashState"
              title="Permalink to HtmlTokenizer.scriptDataEscapedDashState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEscapedDashState() {
 var data = stream.char();
 if (data == "-") {
   _addToken(new CharactersToken("-"));
   state = scriptDataEscapedDashDashState;
 } else if (data == "&lt;") {
   state = scriptDataEscapedLessThanSignState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
   state = scriptDataEscapedState;
 } else if (data == EOF) {
   state = dataState;
 } else {
   _addToken(new CharactersToken(data));
   state = scriptDataEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEscapedEndTagNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEscapedEndTagNameState</strong>() <a class="anchor-link" href="#scriptDataEscapedEndTagNameState"
              title="Permalink to HtmlTokenizer.scriptDataEscapedEndTagNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEscapedEndTagNameState() {
 var appropriate = _tokenIsAppropriate();
 var data = stream.char();
 if (isWhitespace(data) &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   state = beforeAttributeNameState;
 } else if (data == "/" &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   state = selfClosingStartTagState;
 } else if (data == "&gt;" &amp;&amp; appropriate) {
   currentToken = new EndTagToken(temporaryBuffer);
   emitCurrentToken();
   state = dataState;
 } else if (isLetter(data)) {
   temporaryBuffer = '${temporaryBuffer}$data';
 } else {
   _addToken(new CharactersToken("&lt;/$temporaryBuffer"));
   stream.unget(data);
   state = scriptDataEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEscapedEndTagOpenState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEscapedEndTagOpenState</strong>() <a class="anchor-link" href="#scriptDataEscapedEndTagOpenState"
              title="Permalink to HtmlTokenizer.scriptDataEscapedEndTagOpenState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEscapedEndTagOpenState() {
 var data = stream.char();
 if (isLetter(data)) {
   temporaryBuffer = data;
   state = scriptDataEscapedEndTagNameState;
 } else {
   _addToken(new CharactersToken("&lt;/"));
   stream.unget(data);
   state = scriptDataEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEscapedLessThanSignState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEscapedLessThanSignState</strong>() <a class="anchor-link" href="#scriptDataEscapedLessThanSignState"
              title="Permalink to HtmlTokenizer.scriptDataEscapedLessThanSignState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEscapedLessThanSignState() {
 var data = stream.char();
 if (data == "/") {
   temporaryBuffer = "";
   state = scriptDataEscapedEndTagOpenState;
 } else if (isLetter(data)) {
   _addToken(new CharactersToken("&lt;$data"));
   temporaryBuffer = data;
   state = scriptDataDoubleEscapeStartState;
 } else {
   _addToken(new CharactersToken("&lt;"));
   stream.unget(data);
   state = scriptDataEscapedState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEscapedState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEscapedState</strong>() <a class="anchor-link" href="#scriptDataEscapedState"
              title="Permalink to HtmlTokenizer.scriptDataEscapedState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEscapedState() {
 var data = stream.char();
 if (data == "-") {
   _addToken(new CharactersToken("-"));
   state = scriptDataEscapedDashState;
 } else if (data == "&lt;") {
   state = scriptDataEscapedLessThanSignState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
 } else if (data == EOF) {
   state = dataState;
 } else {
   var chars = stream.charsUntil("&lt;-\u0000");
   _addToken(new CharactersToken("${data}${chars}"));
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEscapeStartDashState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEscapeStartDashState</strong>() <a class="anchor-link" href="#scriptDataEscapeStartDashState"
              title="Permalink to HtmlTokenizer.scriptDataEscapeStartDashState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEscapeStartDashState() {
 var data = stream.char();
 if (data == "-") {
   _addToken(new CharactersToken("-"));
   state = scriptDataEscapedDashDashState;
 } else {
   stream.unget(data);
   state = scriptDataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataEscapeStartState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataEscapeStartState</strong>() <a class="anchor-link" href="#scriptDataEscapeStartState"
              title="Permalink to HtmlTokenizer.scriptDataEscapeStartState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataEscapeStartState() {
 var data = stream.char();
 if (data == "-") {
   _addToken(new CharactersToken("-"));
   state = scriptDataEscapeStartDashState;
 } else {
   stream.unget(data);
   state = scriptDataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataLessThanSignState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataLessThanSignState</strong>() <a class="anchor-link" href="#scriptDataLessThanSignState"
              title="Permalink to HtmlTokenizer.scriptDataLessThanSignState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataLessThanSignState() {
 var data = stream.char();
 if (data == "/") {
   temporaryBuffer = "";
   state = scriptDataEndTagOpenState;
 } else if (data == "!") {
   _addToken(new CharactersToken("&lt;!"));
   state = scriptDataEscapeStartState;
 } else {
   _addToken(new CharactersToken("&lt;"));
   stream.unget(data);
   state = scriptDataState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="scriptDataState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>scriptDataState</strong>() <a class="anchor-link" href="#scriptDataState"
              title="Permalink to HtmlTokenizer.scriptDataState">#</a></h4>
<div class="doc">
<pre class="source">
bool scriptDataState() {
 var data = stream.char();
 if (data == "&lt;") {
   state = scriptDataLessThanSignState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   _addToken(new CharactersToken("\uFFFD"));
 } else if (data == EOF) {
   // Tokenization ends.
   return false;
 } else {
   var chars = stream.charsUntil("&lt;\u0000");
   _addToken(new CharactersToken("${data}${chars}"));
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="selfClosingStartTagState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>selfClosingStartTagState</strong>() <a class="anchor-link" href="#selfClosingStartTagState"
              title="Permalink to HtmlTokenizer.selfClosingStartTagState">#</a></h4>
<div class="doc">
<pre class="source">
bool selfClosingStartTagState() {
 var data = stream.char();
 if (data == "&gt;") {
   currentTagToken.selfClosing = true;
   emitCurrentToken();
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("unexpected-EOF-after-solidus-in-tag"));
   stream.unget(data);
   state = dataState;
 } else {
   _addToken(new ParseErrorToken(
       "unexpected-character-after-soldius-in-tag"));
   stream.unget(data);
   state = beforeAttributeNameState;
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="tagNameState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>tagNameState</strong>() <a class="anchor-link" href="#tagNameState"
              title="Permalink to HtmlTokenizer.tagNameState">#</a></h4>
<div class="doc">
<pre class="source">
bool tagNameState() {
 var data = stream.char();
 if (isWhitespace(data)) {
   state = beforeAttributeNameState;
 } else if (data == "&gt;") {
   emitCurrentToken();
 } else if (data == EOF) {
   _addToken(new ParseErrorToken("eof-in-tag-name"));
   state = dataState;
 } else if (data == "/") {
   state = selfClosingStartTagState;
 } else if (data == "\u0000") {
   _addToken(new ParseErrorToken("invalid-codepoint"));
   currentTagToken.name = '${currentTagToken.name}\uFFFD';
 } else {
   currentTagToken.name = '${currentTagToken.name}$data';
   // (Don't use charsUntil here, because tag names are
   // very short and it's faster to not do anything fancy)
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="tagOpenState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>tagOpenState</strong>() <a class="anchor-link" href="#tagOpenState"
              title="Permalink to HtmlTokenizer.tagOpenState">#</a></h4>
<div class="doc">
<pre class="source">
bool tagOpenState() {
 var data = stream.char();
 if (data == "!") {
   state = markupDeclarationOpenState;
 } else if (data == "/") {
   state = closeTagOpenState;
 } else if (isLetter(data)) {
   currentToken = new StartTagToken(data);
   state = tagNameState;
 } else if (data == "&gt;") {
   // XXX In theory it could be something besides a tag name. But
   // do we really care?
   _addToken(new ParseErrorToken(
       "expected-tag-name-but-got-right-bracket"));
   _addToken(new CharactersToken("&lt;&gt;"));
   state = dataState;
 } else if (data == "?") {
   // XXX In theory it could be something besides a tag name. But
   // do we really care?
   _addToken(new ParseErrorToken(
       "expected-tag-name-but-got-question-mark"));
   stream.unget(data);
   state = bogusCommentState;
 } else {
   // XXX
   _addToken(new ParseErrorToken("expected-tag-name"));
   _addToken(new CharactersToken("&lt;"));
   stream.unget(data);
   state = dataState;
 }
 return true;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
