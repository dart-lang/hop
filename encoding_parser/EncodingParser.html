        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>EncodingParser class / encoding_parser Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="encoding_parser" data-type="EncodingParser">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../encoding_parser.html">encoding_parser</a> &rsaquo; <a href="../encoding_parser/EncodingParser.html">EncodingParser</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>EncodingParser</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Mini parser for detecting character encoding from meta elements. </p>
<pre class="source">
class EncodingParser {
 final EncodingBytes data;
 String encoding;

 /** [bytes] - the data to work on for encoding detection. */
 EncodingParser(List&lt;int&gt; bytes)
     // Note: this is intentionally interpreting bytes as codepoints.
     : data = new EncodingBytes(new String.fromCharCodes(bytes).toLowerCase());

 String getEncoding() {
   final methodDispatch = [
     ["&lt;!--", handleComment],
     ["&lt;meta", handleMeta],
     ["&lt;/", handlePossibleEndTag],
     ["&lt;!", handleOther],
     ["&lt;?", handleOther],
     ["&lt;", handlePossibleStartTag]];

   try {
     for (var byte in data) {
       var keepParsing = true;
       for (var dispatch in methodDispatch) {
         if (data.matchBytes(dispatch[0])) {
           try {
             keepParsing = dispatch[1]();
             break;
           } on StateError catch (e) {
             keepParsing = false;
             break;
           }
         }
       }
       if (!keepParsing) {
         break;
       }
     }
   } on StateError catch (e) {
     // Catch this here to match behavior of Python's StopIteration
   }
   return encoding;
 }

 /** Skip over comments. */
 bool handleComment() =&gt; data.jumpTo("--&gt;");

 bool handleMeta() {
   if (!isWhitespace(data.currentByte)) {
     // if we have &lt;meta not followed by a space so just keep going
     return true;
   }
   // We have a valid meta element we want to search for attributes
   while (true) {
     // Try to find the next attribute after the current position
     var attr = getAttribute();
     if (attr == null) return true;

     if (attr[0] == "charset") {
       var tentativeEncoding = attr[1];
       var codec = codecName(tentativeEncoding);
       if (codec != null) {
         encoding = codec;
         return false;
       }
     } else if (attr[0] == "content") {
       var contentParser = new ContentAttrParser(new EncodingBytes(attr[1]));
       var tentativeEncoding = contentParser.parse();
       var codec = codecName(tentativeEncoding);
       if (codec != null) {
         encoding = codec;
         return false;
       }
     }
   }
 }

 bool handlePossibleStartTag() =&gt; handlePossibleTag(false);

 bool handlePossibleEndTag() {
   data.next();
   return handlePossibleTag(true);
 }

 bool handlePossibleTag(bool endTag) {
   if (!isLetter(data.currentByte)) {
     //If the next byte is not an ascii letter either ignore this
     //fragment (possible start tag case) or treat it according to
     //handleOther
     if (endTag) {
       data.previous();
       handleOther();
     }
     return true;
   }

   var c = data.skipUntil(isSpaceOrAngleBracket);
   if (c == "&lt;") {
     // return to the first step in the overall "two step" algorithm
     // reprocessing the &lt; byte
     data.previous();
   } else {
     //Read all attributes
     var attr = getAttribute();
     while (attr != null) {
       attr = getAttribute();
     }
   }
   return true;
 }

 bool handleOther() =&gt; data.jumpTo("&gt;");

 /**
  * Return a name,value pair for the next attribute in the stream,
  * if one is found, or null
  */
 List&lt;String&gt; getAttribute() {
   // Step 1 (skip chars)
   var c = data.skipChars((x) =&gt; x == "/" || isWhitespace(x));
   // Step 2
   if (c == "&gt;" || c == null) {
     return null;
   }
   // Step 3
   var attrName = [];
   var attrValue = [];
   // Step 4 attribute name
   while (true) {
     if (c == null) {
       return null;
     } else if (c == "=" &amp;&amp; attrName.length &gt; 0) {
       break;
     } else if (isWhitespace(c)) {
       // Step 6!
       c = data.skipChars();
       c = data.next();
       break;
     } else if (c == "/" || c == "&gt;") {
       return [attrName.join(), ""];
     } else if (isLetter(c)) {
       attrName.add(c.toLowerCase());
     } else {
       attrName.add(c);
     }
     // Step 5
     c = data.next();
   }
   // Step 7
   if (c != "=") {
     data.previous();
     return [attrName.join(), ""];
   }
   // Step 8
   data.next();
   // Step 9
   c = data.skipChars();
   // Step 10
   if (c == "'" || c == '"') {
     // 10.1
     var quoteChar = c;
     while (true) {
       // 10.2
       c = data.next();
       if (c == quoteChar) {
         // 10.3
         data.next();
         return [attrName.join(), attrValue.join()];
       } else if (isLetter(c)) {
         // 10.4
         attrValue.add(c.toLowerCase());
       } else {
         // 10.5
         attrValue.add(c);
       }
     }
   } else if (c == "&gt;") {
     return [attrName.join(), ""];
   } else if (c == null) {
     return null;
   } else if (isLetter(c)) {
     attrValue.add(c.toLowerCase());
   } else {
     attrValue.add(c);
   }
   // Step 11
   while (true) {
     c = data.next();
     if (isSpaceOrAngleBracket(c)) {
       return [attrName.join(), attrValue.join()];
     } else if (c == null) {
       return null;
     } else if (isLetter(c)) {
       attrValue.add(c.toLowerCase());
     } else {
       attrValue.add(c);
     }
   }
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>EncodingParser</strong>(<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/int.html">int</a>&gt; bytes) <a class="anchor-link" href="#"
              title="Permalink to EncodingParser.EncodingParser">#</a></h4>
<div class="doc">
<p>
<span class="param">bytes</span> - the data to work on for encoding detection. </p>
<pre class="source">
EncodingParser(List&lt;int&gt; bytes)
   // Note: this is intentionally interpreting bytes as codepoints.
   : data = new EncodingBytes(new String.fromCharCodes(bytes).toLowerCase());
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="data">
<button class="show-code">Code</button>
final <a href="../encoding_parser/EncodingBytes.html">EncodingBytes</a>         <strong>data</strong> <a class="anchor-link"
            href="#data"
            title="Permalink to EncodingParser.data">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final EncodingBytes data
</pre>
</div>
</div>
<div class="field"><h4 id="encoding">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>encoding</strong> <a class="anchor-link"
            href="#encoding"
            title="Permalink to EncodingParser.encoding">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String encoding
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="getAttribute">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; <strong>getAttribute</strong>() <a class="anchor-link" href="#getAttribute"
              title="Permalink to EncodingParser.getAttribute">#</a></h4>
<div class="doc">
<p>Return a name,value pair for the next attribute in the stream,
if one is found, or null</p>
<pre class="source">
List&lt;String&gt; getAttribute() {
 // Step 1 (skip chars)
 var c = data.skipChars((x) =&gt; x == "/" || isWhitespace(x));
 // Step 2
 if (c == "&gt;" || c == null) {
   return null;
 }
 // Step 3
 var attrName = [];
 var attrValue = [];
 // Step 4 attribute name
 while (true) {
   if (c == null) {
     return null;
   } else if (c == "=" &amp;&amp; attrName.length &gt; 0) {
     break;
   } else if (isWhitespace(c)) {
     // Step 6!
     c = data.skipChars();
     c = data.next();
     break;
   } else if (c == "/" || c == "&gt;") {
     return [attrName.join(), ""];
   } else if (isLetter(c)) {
     attrName.add(c.toLowerCase());
   } else {
     attrName.add(c);
   }
   // Step 5
   c = data.next();
 }
 // Step 7
 if (c != "=") {
   data.previous();
   return [attrName.join(), ""];
 }
 // Step 8
 data.next();
 // Step 9
 c = data.skipChars();
 // Step 10
 if (c == "'" || c == '"') {
   // 10.1
   var quoteChar = c;
   while (true) {
     // 10.2
     c = data.next();
     if (c == quoteChar) {
       // 10.3
       data.next();
       return [attrName.join(), attrValue.join()];
     } else if (isLetter(c)) {
       // 10.4
       attrValue.add(c.toLowerCase());
     } else {
       // 10.5
       attrValue.add(c);
     }
   }
 } else if (c == "&gt;") {
   return [attrName.join(), ""];
 } else if (c == null) {
   return null;
 } else if (isLetter(c)) {
   attrValue.add(c.toLowerCase());
 } else {
   attrValue.add(c);
 }
 // Step 11
 while (true) {
   c = data.next();
   if (isSpaceOrAngleBracket(c)) {
     return [attrName.join(), attrValue.join()];
   } else if (c == null) {
     return null;
   } else if (isLetter(c)) {
     attrValue.add(c.toLowerCase());
   } else {
     attrValue.add(c);
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="getEncoding">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a> <strong>getEncoding</strong>() <a class="anchor-link" href="#getEncoding"
              title="Permalink to EncodingParser.getEncoding">#</a></h4>
<div class="doc">
<pre class="source">
String getEncoding() {
 final methodDispatch = [
   ["&lt;!--", handleComment],
   ["&lt;meta", handleMeta],
   ["&lt;/", handlePossibleEndTag],
   ["&lt;!", handleOther],
   ["&lt;?", handleOther],
   ["&lt;", handlePossibleStartTag]];

 try {
   for (var byte in data) {
     var keepParsing = true;
     for (var dispatch in methodDispatch) {
       if (data.matchBytes(dispatch[0])) {
         try {
           keepParsing = dispatch[1]();
           break;
         } on StateError catch (e) {
           keepParsing = false;
           break;
         }
       }
     }
     if (!keepParsing) {
       break;
     }
   }
 } on StateError catch (e) {
   // Catch this here to match behavior of Python's StopIteration
 }
 return encoding;
}
</pre>
</div>
</div>
<div class="method"><h4 id="handleComment">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>handleComment</strong>() <a class="anchor-link" href="#handleComment"
              title="Permalink to EncodingParser.handleComment">#</a></h4>
<div class="doc">
<p>Skip over comments. </p>
<pre class="source">
bool handleComment() =&gt; data.jumpTo("--&gt;");
</pre>
</div>
</div>
<div class="method"><h4 id="handleMeta">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>handleMeta</strong>() <a class="anchor-link" href="#handleMeta"
              title="Permalink to EncodingParser.handleMeta">#</a></h4>
<div class="doc">
<pre class="source">
bool handleMeta() {
 if (!isWhitespace(data.currentByte)) {
   // if we have &lt;meta not followed by a space so just keep going
   return true;
 }
 // We have a valid meta element we want to search for attributes
 while (true) {
   // Try to find the next attribute after the current position
   var attr = getAttribute();
   if (attr == null) return true;

   if (attr[0] == "charset") {
     var tentativeEncoding = attr[1];
     var codec = codecName(tentativeEncoding);
     if (codec != null) {
       encoding = codec;
       return false;
     }
   } else if (attr[0] == "content") {
     var contentParser = new ContentAttrParser(new EncodingBytes(attr[1]));
     var tentativeEncoding = contentParser.parse();
     var codec = codecName(tentativeEncoding);
     if (codec != null) {
       encoding = codec;
       return false;
     }
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="handleOther">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>handleOther</strong>() <a class="anchor-link" href="#handleOther"
              title="Permalink to EncodingParser.handleOther">#</a></h4>
<div class="doc">
<pre class="source">
bool handleOther() =&gt; data.jumpTo("&gt;");
</pre>
</div>
</div>
<div class="method"><h4 id="handlePossibleEndTag">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>handlePossibleEndTag</strong>() <a class="anchor-link" href="#handlePossibleEndTag"
              title="Permalink to EncodingParser.handlePossibleEndTag">#</a></h4>
<div class="doc">
<pre class="source">
bool handlePossibleEndTag() {
 data.next();
 return handlePossibleTag(true);
}
</pre>
</div>
</div>
<div class="method"><h4 id="handlePossibleStartTag">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>handlePossibleStartTag</strong>() <a class="anchor-link" href="#handlePossibleStartTag"
              title="Permalink to EncodingParser.handlePossibleStartTag">#</a></h4>
<div class="doc">
<pre class="source">
bool handlePossibleStartTag() =&gt; handlePossibleTag(false);
</pre>
</div>
</div>
<div class="method"><h4 id="handlePossibleTag">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>handlePossibleTag</strong>(<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> endTag) <a class="anchor-link" href="#handlePossibleTag"
              title="Permalink to EncodingParser.handlePossibleTag">#</a></h4>
<div class="doc">
<pre class="source">
bool handlePossibleTag(bool endTag) {
 if (!isLetter(data.currentByte)) {
   //If the next byte is not an ascii letter either ignore this
   //fragment (possible start tag case) or treat it according to
   //handleOther
   if (endTag) {
     data.previous();
     handleOther();
   }
   return true;
 }

 var c = data.skipUntil(isSpaceOrAngleBracket);
 if (c == "&lt;") {
   // return to the first step in the overall "two step" algorithm
   // reprocessing the &lt; byte
   data.previous();
 } else {
   //Read all attributes
   var attr = getAttribute();
   while (attr != null) {
     attr = getAttribute();
   }
 }
 return true;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
