        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Runner class / hop Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="hop" data-type="Runner">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../hop.html">hop</a> &rsaquo; <a href="../hop/Runner.html">Runner</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Runner</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Runner {
 /**
  * Runs a [Task] with the specificed [TaskContext].
  *
  * [runTask] handles a number of error cases, logs appropriate messages
  * to [context] and returns a corresponding [RunResult] when completed.
  */
 static Future&lt;RunResult&gt; runTask(TaskContext context, Task task,
     {Level printAtLogLevel}) {

   requireArgumentNotNull(context, 'context');
   requireArgumentNotNull(task, 'task');
   requireArgument(!context.isDisposed, 'context', 'cannot be disposed');

   final start = new DateTime.now();
   context.finest('Started at $start');

   return task.run(context, printAtLogLevel: printAtLogLevel)
       .then((value) {
         // TODO: remove these checks at some future version
         if(value == true) {
           context.severe('`true` was returned from the task.\n'
               "It's possible that the task was trying to signal success using"
               "an old behavior.\nThis is no longer nessesary.");
         } else if(value == false) {
           context.severe("`false` was returned from the task.\n"
               "It's possible that the task was trying to signal failure using"
               "an old behavior.\nTasks should signal failure using "
               "`TaskContext.fail`.");
         }

         return RunResult.SUCCESS;
       })
       .catchError((Object error, StackTrace stack) {
         if(error == Task._NULL_FUTURE_RESULT_EX) {
           context.severe('The task returned null instead of a future');
           return RunResult.ERROR;
         } else if(error is _TaskFailError) {
           final _TaskFailError e = error;
           context.severe(e.message);
           return RunResult.FAIL;
         } else {
           // has as exception, need to test this
           context.severe('Exception thrown by task');
           context.severe(error.toString());

           if(error is Error &amp;&amp; stack == null) {
             // TODO: should this ever be the case? Weird...
             stack = error.stackTrace;
           }

           if(stack != null) {
             context.severe(stack.toString());
           }
           return RunResult.EXCEPTION;
         }
       })
       .whenComplete(() {
         final end = new DateTime.now();
         context.finest('Finished at $end');
         final duration = end.difference(start);
         context.finer('Run time: $duration');
       });
 }

 /**
  * [run] exists primarily for testing [Task] implementations.
  *
  * If you want to use Hop in an app, see [runHop].
  *
  * If you want to run a specific [Task] in isolation, see [runTask].
  */
 static Future&lt;RunResult&gt; run(HopConfig config, {Level printAtLogLevel}) {
   requireArgumentNotNull(config, 'config');

   final ctx = _getContext(config);

   if(config.args.command != null) {
     // we're executing a command
     final subCommandArgResults = config.args.command;
     final taskName = subCommandArgResults.name;

     var subCtx = ctx.getSubContext(taskName, subCommandArgResults);

     final task = config.taskRegistry.tasks[taskName];
     return runTask(subCtx, task, printAtLogLevel: printAtLogLevel)
         .then((RunResult result) =&gt; _logExitCode(ctx, result))
         .whenComplete(() {
           subCtx.dispose();
         });

   } else if(config.args.rest.length == 0) {
     _printHelp(config.doPrint, config.taskRegistry, config.parser);
     return new Future.value(RunResult.SUCCESS);
   } else {
     final taskName = config.args.rest[0];
     ctx.log('No task named "$taskName".');
     return new Future.value(RunResult.BAD_USAGE);
   }
 }

 static RootTaskContext _getContext(HopConfig config) {
   final bool preFixEnabled = config.args[_PREFIX_FLAG];
   final String logLevelOption = config.args[_LOG_LEVEL_OPTION];

   final Level logLevel = _sortedLogLevels
       .singleWhere((Level l) =&gt; l.name.toLowerCase() == logLevelOption);

   return new RootTaskContext(config.doPrint,
       prefixEnabled: preFixEnabled, minLogLevel: logLevel);
 }

 static void _runShell(List&lt;String&gt; mainArgs, TaskRegistry registry,
                       String helpTaskName, Level printAtLogLevel) {

   // a bit ugly
   // the help task needs the parser and a print method
   // we can't get those until the help task is created
   // so we use this dummy object which the help task closure holds onto
   // then we update the values before the help task could ever be called
   // sorry. Weird, I know
   final helpArgs = new _HelpArgs(registry);

   // wire up help task
   if(helpTaskName != null) {
     assert(registry._helpTaskName == null);
     registry._helpTaskName = helpTaskName;
     registry.addTask(helpTaskName, _getHelpTask(helpArgs));
   }

   registry._freeze();

   final parser = _getParser(registry, Level.INFO);
   helpArgs.parser = parser;

   ArgResults args;
   try {
     args = tryArgsCompletion(mainArgs, parser);
   } on FormatException catch(ex, stack) {
     // TODO: try to guess if --no-color was passed in here?
     print("There was an error parsing the provided arguments");
     print(ex.message);
     print('');
     _printHelp(print, registry, parser);

     _libLogger.severe(ex.message);
     _libLogger.severe(Error.safeToString(stack));

     io.exit(RunResult.BAD_USAGE.exitCode);
   }

   final bool useColor = args[_COLOR_FLAG];
   final Printer printer = _colorPrinter(Zone.current.print, useColor);

   final config = new HopConfig._internal(registry, parser, args, printer);
   helpArgs.printer = config.doPrint;

   final future = Runner.run(config, printAtLogLevel: printAtLogLevel);

   future.then((RunResult rr) {
     _libLogger.info('Exit with $rr');
     io.exit(rr.exitCode);
   });
 }

 static Function _colorPrinter(void corePrint(String line), bool useColor) {
   return (Object value) {

     if(value is ShellString &amp;&amp; useColor) {
       value = (value as ShellString).format(true);
     }

     value = value.toString();

     corePrint(value);
   };
 }

 static RunResult _logExitCode(RootTaskContext ctx, RunResult result) {
   if(!result.success) {
     final msg = 'Task did not complete - ${result.name} (${result.exitCode})';
     ctx.log(new ShellString.withColor(msg, AnsiColor.RED));
   }
   return result;
 }
}
</pre>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="runTask">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../hop/RunResult.html">RunResult</a>&gt; <strong>runTask</strong>(<a href="../hop/TaskContext.html">TaskContext</a> context, <a href="../hop/Task.html">Task</a> task, {<a href="../logging/Level.html">Level</a> printAtLogLevel}) <a class="anchor-link" href="#runTask"
              title="Permalink to Runner.runTask">#</a></h4>
<div class="doc">
<p>Runs a <a class="crossref" href="../hop/Task.html">Task</a> with the specificed <a class="crossref" href="../hop/TaskContext.html">TaskContext</a>.</p>
<p><a class="crossref" href="../hop/Runner.html#runTask">runTask</a> handles a number of error cases, logs appropriate messages
to 
<span class="param">context</span> and returns a corresponding <a class="crossref" href="../hop/RunResult.html">RunResult</a> when completed.</p>
<pre class="source">
static Future&lt;RunResult&gt; runTask(TaskContext context, Task task,
   {Level printAtLogLevel}) {

 requireArgumentNotNull(context, 'context');
 requireArgumentNotNull(task, 'task');
 requireArgument(!context.isDisposed, 'context', 'cannot be disposed');

 final start = new DateTime.now();
 context.finest('Started at $start');

 return task.run(context, printAtLogLevel: printAtLogLevel)
     .then((value) {
       // TODO: remove these checks at some future version
       if(value == true) {
         context.severe('`true` was returned from the task.\n'
             "It's possible that the task was trying to signal success using"
             "an old behavior.\nThis is no longer nessesary.");
       } else if(value == false) {
         context.severe("`false` was returned from the task.\n"
             "It's possible that the task was trying to signal failure using"
             "an old behavior.\nTasks should signal failure using "
             "`TaskContext.fail`.");
       }

       return RunResult.SUCCESS;
     })
     .catchError((Object error, StackTrace stack) {
       if(error == Task._NULL_FUTURE_RESULT_EX) {
         context.severe('The task returned null instead of a future');
         return RunResult.ERROR;
       } else if(error is _TaskFailError) {
         final _TaskFailError e = error;
         context.severe(e.message);
         return RunResult.FAIL;
       } else {
         // has as exception, need to test this
         context.severe('Exception thrown by task');
         context.severe(error.toString());

         if(error is Error &amp;&amp; stack == null) {
           // TODO: should this ever be the case? Weird...
           stack = error.stackTrace;
         }

         if(stack != null) {
           context.severe(stack.toString());
         }
         return RunResult.EXCEPTION;
       }
     })
     .whenComplete(() {
       final end = new DateTime.now();
       context.finest('Finished at $end');
       final duration = end.difference(start);
       context.finer('Run time: $duration');
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="run">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../hop/RunResult.html">RunResult</a>&gt; <strong>run</strong>(<a href="../hop/HopConfig.html">HopConfig</a> config, {<a href="../logging/Level.html">Level</a> printAtLogLevel}) <a class="anchor-link" href="#run"
              title="Permalink to Runner.run">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../hop/Runner.html#run">run</a> exists primarily for testing <a class="crossref" href="../hop/Task.html">Task</a> implementations.</p>
<p>If you want to use Hop in an app, see <a class="crossref" href="../hop.html#runHop">runHop</a>.</p>
<p>If you want to run a specific <a class="crossref" href="../hop/Task.html">Task</a> in isolation, see <a class="crossref" href="../hop/Runner.html#runTask">runTask</a>.</p>
<pre class="source">
static Future&lt;RunResult&gt; run(HopConfig config, {Level printAtLogLevel}) {
 requireArgumentNotNull(config, 'config');

 final ctx = _getContext(config);

 if(config.args.command != null) {
   // we're executing a command
   final subCommandArgResults = config.args.command;
   final taskName = subCommandArgResults.name;

   var subCtx = ctx.getSubContext(taskName, subCommandArgResults);

   final task = config.taskRegistry.tasks[taskName];
   return runTask(subCtx, task, printAtLogLevel: printAtLogLevel)
       .then((RunResult result) =&gt; _logExitCode(ctx, result))
       .whenComplete(() {
         subCtx.dispose();
       });

 } else if(config.args.rest.length == 0) {
   _printHelp(config.doPrint, config.taskRegistry, config.parser);
   return new Future.value(RunResult.SUCCESS);
 } else {
   final taskName = config.args.rest[0];
   ctx.log('No task named "$taskName".');
   return new Future.value(RunResult.BAD_USAGE);
 }
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
