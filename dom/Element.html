        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Element class / dom Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="dom" data-type="Element">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../dom.html">dom</a> &rsaquo; <a href="../dom/Element.html">Element</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Element</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Element extends Node {
 final String namespace;

 // TODO(jmesserly): deprecate in favor of Element.tag? Or rename?
 Element(String name, [this.namespace]) : super(name);

 Element.tag(String name) : namespace = null, super(name);

 static final _START_TAG_REGEXP = new RegExp('&lt;(\\w+)');

 static final _CUSTOM_PARENT_TAG_MAP = const {
   'body': 'html',
   'head': 'html',
   'caption': 'table',
   'td': 'tr',
   'colgroup': 'table',
   'col': 'colgroup',
   'tr': 'tbody',
   'tbody': 'table',
   'tfoot': 'table',
   'thead': 'table',
   'track': 'audio',
 };

 // TODO(jmesserly): this is from dart:html _ElementFactoryProvider...
 // TODO(jmesserly): have a look at fixing some things in dart:html, in
 // particular: is the parent tag map complete? Is it faster without regexp?
 // TODO(jmesserly): for our version we can do something smarter in the parser.
 // All we really need is to set the correct parse state.
 factory Element.html(String html) {

   // TODO(jacobr): this method can be made more robust and performant.
   // 1) Cache the dummy parent elements required to use innerHTML rather than
   //    creating them every call.
   // 2) Verify that the html does not contain leading or trailing text nodes.
   // 3) Verify that the html does not contain both &lt;head&gt; and &lt;body&gt; tags.
   // 4) Detatch the created element from its dummy parent.
   String parentTag = 'div';
   String tag;
   final match = _START_TAG_REGEXP.firstMatch(html);
   if (match != null) {
     tag = match.group(1).toLowerCase();
     if (_CUSTOM_PARENT_TAG_MAP.containsKey(tag)) {
       parentTag = _CUSTOM_PARENT_TAG_MAP[tag];
     }
   }

   var fragment = parseFragment(html, container: parentTag);
   Element element;
   if (fragment.children.length == 1) {
     element = fragment.children[0];
   } else if (parentTag == 'html' &amp;&amp; fragment.children.length == 2) {
     // You'll always get a head and a body when starting from html.
     element = fragment.children[tag == 'head' ? 0 : 1];
   } else {
     throw new ArgumentError('HTML had ${fragment.children.length} '
         'top level elements but 1 expected');
   }
   element.remove();
   return element;
 }

 int get nodeType =&gt; Node.ELEMENT_NODE;

 String toString() {
   if (namespace == null) return "&lt;$tagName&gt;";
   return "&lt;${Namespaces.getPrefix(namespace)} $tagName&gt;";
 }

 void _addOuterHtml(StringBuffer str) {
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments
   // Element is the most complicated one.
   if (namespace == null ||
       namespace == Namespaces.html ||
       namespace == Namespaces.mathml ||
       namespace == Namespaces.svg) {
     str.write('&lt;$tagName');
   } else {
     // TODO(jmesserly): the spec doesn't define "qualified name".
     // I'm not sure if this is correct, but it should parse reasonably.
     str.write('&lt;${Namespaces.getPrefix(namespace)}:$tagName');
   }

   if (attributes.length &gt; 0) {
     attributes.forEach((key, v) {
       // Note: AttributeName.toString handles serialization of attribute
       // namespace, if needed.
       str.write(' $key="${htmlSerializeEscape(v, attributeMode: true)}"');
     });
   }

   str.write('&gt;');

   if (nodes.length &gt; 0) {
     if (tagName == 'pre' || tagName == 'textarea' || tagName == 'listing') {
       if (nodes[0] is Text &amp;&amp; nodes[0].value.startsWith('\n')) {
         // These nodes will remove a leading \n at parse time, so if we still
         // have one, it means we started with two. Add it back.
         str.write('\n');
       }
     }

     _addInnerHtml(str);
   }

   // void elements must not have an end tag
   // http://dev.w3.org/html5/markup/syntax.html#void-elements
   if (!isVoidElement(tagName)) str.write('&lt;/$tagName&gt;');
 }

 Element clone() =&gt; new Element(tagName, namespace)
     ..attributes = new LinkedHashMap.from(attributes);

 String get id {
   var result = attributes['id'];
   return result != null ? result : '';
 }

 set id(String value) {
   if (value == null) {
     attributes.remove('id');
   } else {
     attributes['id'] = value;
   }
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../dom/Node.html">Node</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>Element</strong></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Element</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> name, [<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> namespace]) <a class="anchor-link" href="#"
              title="Permalink to Element.Element">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> </div></div>
<pre class="source">
Element(String name, [this.namespace]) : super(name);
</pre>
</div>
</div>
<div class="method"><h4 id="html">
<button class="show-code">Code</button>
factory <strong>Element.html</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> html) <a class="anchor-link" href="#html"
              title="Permalink to Element.Element.html">#</a></h4>
<div class="doc">
<pre class="source">
factory Element.html(String html) {

 // TODO(jacobr): this method can be made more robust and performant.
 // 1) Cache the dummy parent elements required to use innerHTML rather than
 //    creating them every call.
 // 2) Verify that the html does not contain leading or trailing text nodes.
 // 3) Verify that the html does not contain both &lt;head&gt; and &lt;body&gt; tags.
 // 4) Detatch the created element from its dummy parent.
 String parentTag = 'div';
 String tag;
 final match = _START_TAG_REGEXP.firstMatch(html);
 if (match != null) {
   tag = match.group(1).toLowerCase();
   if (_CUSTOM_PARENT_TAG_MAP.containsKey(tag)) {
     parentTag = _CUSTOM_PARENT_TAG_MAP[tag];
   }
 }

 var fragment = parseFragment(html, container: parentTag);
 Element element;
 if (fragment.children.length == 1) {
   element = fragment.children[0];
 } else if (parentTag == 'html' &amp;&amp; fragment.children.length == 2) {
   // You'll always get a head and a body when starting from html.
   element = fragment.children[tag == 'head' ? 0 : 1];
 } else {
   throw new ArgumentError('HTML had ${fragment.children.length} '
       'top level elements but 1 expected');
 }
 element.remove();
 return element;
}
</pre>
</div>
</div>
<div class="method"><h4 id="tag">
<button class="show-code">Code</button>
new <strong>Element.tag</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> name) <a class="anchor-link" href="#tag"
              title="Permalink to Element.Element.tag">#</a></h4>
<div class="doc">
<pre class="source">
Element.tag(String name) : namespace = null, super(name);
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field inherited"><h4 id="$dom_nodeType">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>$dom_nodeType</strong> <a class="anchor-link"
            href="#$dom_nodeType"
            title="Permalink to Element.$dom_nodeType">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
int get $dom_nodeType =&gt; nodeType;
</pre>
</div>
</div>
<div class="field inherited"><h4 id="attributes">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_collection/LinkedHashMap.html" ref="external">LinkedHashMap</a>&lt;dynamic, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt;         <strong>attributes</strong> <a class="anchor-link"
            href="#attributes"
            title="Permalink to Element.attributes">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>A map holding name, value pairs for attributes of the node.</p>
<p>Note that attribute order needs to be stable for serialization, so we use a
LinkedHashMap. Each key is a <a class="crossref" href="http://api.dartlang.org/dart_core/String.html">String</a> or <a class="crossref" href="../dom/AttributeName.html">AttributeName</a>.</p>
<pre class="source">
LinkedHashMap&lt;dynamic, String&gt; attributes = new LinkedHashMap()
</pre>
</div>
</div>
<div class="field inherited"><h4 id="attributeSpans">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_collection/LinkedHashMap.html" ref="external">LinkedHashMap</a>&lt;dynamic, <a href="../source_maps.span/FileSpan.html">FileSpan</a>&gt;         <strong>attributeSpans</strong> <a class="anchor-link"
            href="#attributeSpans"
            title="Permalink to Element.attributeSpans">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>If <code>sourceSpan</code> is available, this contains the spans of each attribute.
The span of an attribute is the entire attribute, including the name and
quotes (if any). For example, the span of "attr" in <code>&lt;a attr="value"&gt;</code>
would be the text <code>attr="value"</code>.</p>
<pre class="source">
LinkedHashMap&lt;dynamic, FileSpan&gt; get attributeSpans {
 _ensureAttributeSpans();
 return _attributeSpans;
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="attributeValueSpans">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_collection/LinkedHashMap.html" ref="external">LinkedHashMap</a>&lt;dynamic, <a href="../source_maps.span/FileSpan.html">FileSpan</a>&gt;         <strong>attributeValueSpans</strong> <a class="anchor-link"
            href="#attributeValueSpans"
            title="Permalink to Element.attributeValueSpans">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>If <code>sourceSpan</code> is available, this contains the spans of each attribute's
value. Unlike <a class="crossref" href="../dom/Node.html#attributeSpans">attributeSpans</a>, this span will inlcude only the value.
For example, the value span of "attr" in <code>&lt;a attr="value"&gt;</code> would be the
text <code>value</code>.</p>
<pre class="source">
LinkedHashMap&lt;dynamic, FileSpan&gt; get attributeValueSpans {
 _ensureAttributeSpans();
 return _attributeValueSpans;
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="children">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../dom/Element.html">Element</a>&gt;         <strong>children</strong> <a class="anchor-link"
            href="#children"
            title="Permalink to Element.children">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
List&lt;Element&gt; get children {
 if (_elements == null) {
   _elements = new FilteredElementList(this);
 }
 return _elements;
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="firstChild">
<button class="show-code">Code</button>
final <a href="../dom/Node.html">Node</a>         <strong>firstChild</strong> <a class="anchor-link"
            href="#firstChild"
            title="Permalink to Element.firstChild">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
Node get firstChild =&gt; nodes.isNotEmpty ? nodes[0] : null;
</pre>
</div>
</div>
<div class="field"><h4 id="id">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>id</strong> <a class="anchor-link"
            href="#id"
            title="Permalink to Element.id">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String get id {
 var result = attributes['id'];
 return result != null ? result : '';
}
</pre>
<pre class="source">
set id(String value) {
 if (value == null) {
   attributes.remove('id');
 } else {
   attributes['id'] = value;
 }
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="innerHtml">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>innerHtml</strong> <a class="anchor-link"
            href="#innerHtml"
            title="Permalink to Element.innerHtml">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
String get innerHtml {
 var str = new StringBuffer();
 _addInnerHtml(str);
 return str.toString();
}
</pre>
<pre class="source">
set innerHtml(String value) {
 nodes.clear();
 // TODO(jmesserly): should be able to get the same effect by adding the
 // fragment directly.
 nodes.addAll(parseFragment(value, container: tagName).nodes);
}
</pre>
</div>
</div>
<div class="field"><h4 id="namespace">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>namespace</strong> <a class="anchor-link"
            href="#namespace"
            title="Permalink to Element.namespace">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final String namespace
</pre>
</div>
</div>
<div class="field inherited"><h4 id="nameTuple">
<button class="show-code">Code</button>
final <a href="../utils/Pair.html">Pair</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt;         <strong>nameTuple</strong> <a class="anchor-link"
            href="#nameTuple"
            title="Permalink to Element.nameTuple">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
Pair&lt;String, String&gt; get nameTuple {
 var ns = namespace != null ? namespace : Namespaces.html;
 return new Pair(ns, tagName);
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="nodes">
<button class="show-code">Code</button>
final <a href="../dom/NodeList.html">NodeList</a>         <strong>nodes</strong> <a class="anchor-link"
            href="#nodes"
            title="Permalink to Element.nodes">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>A list of child nodes of the current node. This must
include all elements but not necessarily other node types.</p>
<pre class="source">
final NodeList nodes = new NodeList._()
</pre>
</div>
</div>
<div class="field"><h4 id="nodeType">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>         <strong>nodeType</strong> <a class="anchor-link"
            href="#nodeType"
            title="Permalink to Element.nodeType">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int get nodeType =&gt; Node.ELEMENT_NODE;
</pre>
</div>
</div>
<div class="field inherited"><h4 id="outerHtml">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>outerHtml</strong> <a class="anchor-link"
            href="#outerHtml"
            title="Permalink to Element.outerHtml">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
String get outerHtml {
 var str = new StringBuffer();
 _addOuterHtml(str);
 return str.toString();
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="parent">
<button class="show-code">Code</button>
<a href="../dom/Node.html">Node</a>         <strong>parent</strong> <a class="anchor-link"
            href="#parent"
            title="Permalink to Element.parent">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>The parent of the current node (or null for the document node). </p>
<pre class="source">
Node parent
</pre>
</div>
</div>
<div class="field inherited"><h4 id="sourceSpan">
<button class="show-code">Code</button>
<a href="../source_maps.span/FileSpan.html">FileSpan</a>         <strong>sourceSpan</strong> <a class="anchor-link"
            href="#sourceSpan"
            title="Permalink to Element.sourceSpan">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>The source span of this node, if it was created by the <a class="crossref" href="../parser/HtmlParser.html">HtmlParser</a>. </p>
<pre class="source">
FileSpan sourceSpan
</pre>
</div>
</div>
<div class="field inherited"><h4 id="tagName">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>tagName</strong> <a class="anchor-link"
            href="#tagName"
            title="Permalink to Element.tagName">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>The tag name associated with the node. </p>
<pre class="source">
final String tagName
</pre>
</div>
</div>
<div class="field inherited"><h4 id="value">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>value</strong> <a class="anchor-link"
            href="#value"
            title="Permalink to Element.value">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>The value of the current node (applies to text nodes and comments). </p>
<pre class="source">
String get value =&gt; null;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="clone">
<button class="show-code">Code</button>
<a href="../dom/Element.html">Element</a> <strong>clone</strong>() <a class="anchor-link" href="#clone"
              title="Permalink to Element.clone">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Return a shallow copy of the current node i.e. a node with the same
name and attributes but with no parent or child nodes.</p>
<div class="docs-inherited-from">docs inherited from <a href="../dom/Node.html">Node</a> </div></div>
<pre class="source">
Element clone() =&gt; new Element(tagName, namespace)
   ..attributes = new LinkedHashMap.from(attributes);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="contains">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>contains</strong>(<a href="../dom/Node.html">Node</a> node) <a class="anchor-link" href="#contains"
              title="Permalink to Element.contains">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
bool contains(Node node) =&gt; nodes.contains(node);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="hasChildNodes">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>hasChildNodes</strong>() <a class="anchor-link" href="#hasChildNodes"
              title="Permalink to Element.hasChildNodes">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
bool hasChildNodes() =&gt; !nodes.isEmpty;
</pre>
</div>
</div>
<div class="method inherited"><h4 id="hasContent">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>hasContent</strong>() <a class="anchor-link" href="#hasContent"
              title="Permalink to Element.hasContent">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>Return true if the node has children or text. </p>
<pre class="source">
bool hasContent() =&gt; nodes.length &gt; 0;
</pre>
</div>
</div>
<div class="method inherited"><h4 id="insertBefore">
<button class="show-code">Code</button>
void <strong>insertBefore</strong>(<a href="../dom/Node.html">Node</a> node, <a href="../dom/Node.html">Node</a> refNode) <a class="anchor-link" href="#insertBefore"
              title="Permalink to Element.insertBefore">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>Insert 
<span class="param">node</span> as a child of the current node, before 
<span class="param">refNode</span> in the
list of child nodes. Raises <code>UnsupportedOperationException</code> if 
<span class="param">refNode</span>
is not a child of the current node. If refNode is null, this adds to the
end of the list.</p>
<pre class="source">
void insertBefore(Node node, Node refNode) {
 if (refNode == null) {
   nodes.add(node);
 } else {
   nodes.insert(nodes.indexOf(refNode), node);
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="query">
<button class="show-code">Code</button>
<a href="../dom/Element.html">Element</a> <strong>query</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> selectors) <a class="anchor-link" href="#query"
              title="Permalink to Element.query">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>Seaches for the first descendant node matching the given selectors, using a
preorder traversal. NOTE: right now, this supports only a single type
selectors, e.g. <code>node.query('div')</code>.</p>
<pre class="source">
Element query(String selectors) =&gt; _queryType(_typeSelector(selectors));
</pre>
</div>
</div>
<div class="method inherited"><h4 id="queryAll">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../dom/Element.html">Element</a>&gt; <strong>queryAll</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> selectors) <a class="anchor-link" href="#queryAll"
              title="Permalink to Element.queryAll">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>Returns all descendant nodes matching the given selectors, using a
preorder traversal. NOTE: right now, this supports only a single type
selectors, e.g. <code>node.queryAll('div')</code>.</p>
<pre class="source">
List&lt;Element&gt; queryAll(String selectors) {
 var results = new List&lt;Element&gt;();
 _queryAllType(_typeSelector(selectors), results);
 return results;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="remove">
<button class="show-code">Code</button>
<a href="../dom/Node.html">Node</a> <strong>remove</strong>() <a class="anchor-link" href="#remove"
              title="Permalink to Element.remove">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<pre class="source">
Node remove() {
 // TODO(jmesserly): is parent == null an error?
 if (parent != null) {
   parent.nodes.remove(this);
 }
 return this;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="reparentChildren">
<button class="show-code">Code</button>
void <strong>reparentChildren</strong>(<a href="../dom/Node.html">Node</a> newParent) <a class="anchor-link" href="#reparentChildren"
              title="Permalink to Element.reparentChildren">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>Move all the children of the current node to 
<span class="param">newParent</span>.
This is needed so that trees that don't store text as nodes move the
text in the correct way.</p>
<pre class="source">
void reparentChildren(Node newParent) {
 newParent.nodes.addAll(nodes);
 nodes.clear();
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="replaceWith">
<button class="show-code">Code</button>
<a href="../dom/Node.html">Node</a> <strong>replaceWith</strong>(<a href="../dom/Node.html">Node</a> otherNode) <a class="anchor-link" href="#replaceWith"
              title="Permalink to Element.replaceWith">#</a></h4>
<div class="inherited-from">inherited from <a href="../dom/Node.html">Node</a> </div><div class="doc">
<p>Replaces this node with another node. </p>
<pre class="source">
Node replaceWith(Node otherNode) {
 if (parent == null) {
   throw new UnsupportedError('Node must have a parent to replace it.');
 }
 parent.nodes[parent.nodes.indexOf(this)] = otherNode;
 return this;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to Element.toString">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns a string representation of this object.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> </div></div>
<pre class="source">
String toString() {
 if (namespace == null) return "&lt;$tagName&gt;";
 return "&lt;${Namespaces.getPrefix(namespace)} $tagName&gt;";
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
