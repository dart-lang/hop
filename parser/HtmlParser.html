        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>HtmlParser class / parser Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="parser" data-type="HtmlParser">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../parser.html">parser</a> &rsaquo; <a href="../parser/HtmlParser.html">HtmlParser</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>HtmlParser</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Parser for HTML, which generates a tree structure from a stream of
(possibly malformed) characters.</p>
<pre class="source">
class HtmlParser {
 /** Raise an exception on the first error encountered. */
 final bool strict;

 /** True to generate [Span]s for the [Node.sourceSpan] property. */
 final bool generateSpans;

 final HtmlTokenizer tokenizer;

 final TreeBuilder tree;

 final List&lt;ParseError&gt; errors = &lt;ParseError&gt;[];

 String container;

 bool firstStartTag = false;

 // TODO(jmesserly): use enum?
 /** "quirks" / "limited quirks" / "no quirks" */
 String compatMode = "no quirks";

 /** innerHTML container when parsing document fragment. */
 String innerHTML;

 Phase phase;

 Phase lastPhase;

 Phase originalPhase;

 Phase beforeRCDataPhase;

 bool framesetOK;

 // These fields hold the different phase singletons. At any given time one
 // of them will be active.
 InitialPhase _initialPhase;
 BeforeHtmlPhase _beforeHtmlPhase;
 BeforeHeadPhase _beforeHeadPhase;
 InHeadPhase _inHeadPhase;
 AfterHeadPhase _afterHeadPhase;
 InBodyPhase _inBodyPhase;
 TextPhase _textPhase;
 InTablePhase _inTablePhase;
 InTableTextPhase _inTableTextPhase;
 InCaptionPhase _inCaptionPhase;
 InColumnGroupPhase _inColumnGroupPhase;
 InTableBodyPhase _inTableBodyPhase;
 InRowPhase _inRowPhase;
 InCellPhase _inCellPhase;
 InSelectPhase _inSelectPhase;
 InSelectInTablePhase _inSelectInTablePhase;
 InForeignContentPhase _inForeignContentPhase;
 AfterBodyPhase _afterBodyPhase;
 InFramesetPhase _inFramesetPhase;
 AfterFramesetPhase _afterFramesetPhase;
 AfterAfterBodyPhase _afterAfterBodyPhase;
 AfterAfterFramesetPhase _afterAfterFramesetPhase;

 /**
  * Create a new HtmlParser and configure the [tree] builder and [strict] mode.
  * The [input] can be a [String], [List&lt;int&gt;] of bytes or an [HtmlTokenizer].
  *
  * If [input] is not a [HtmlTokenizer], you can specify a few more arguments.
  *
  * The [encoding] must be a string that indicates the encoding. If specified,
  * that encoding will be used, regardless of any BOM or later declaration
  * (such as in a meta element).
  *
  * Set [parseMeta] to false if you want to disable parsing the meta element.
  *
  * Set [lowercaseElementName] or [lowercaseAttrName] to false to disable the
  * automatic conversion of element and attribute names to lower case. Note
  * that standard way to parse HTML is to lowercase, which is what the browser
  * DOM will do if you request [Node.outerHTML], for example.
  */
 HtmlParser(input, {String encoding, bool parseMeta: true,
     bool lowercaseElementName: true, bool lowercaseAttrName: true,
     this.strict: false, bool generateSpans: false, String sourceUrl,
     TreeBuilder tree})
     : generateSpans = generateSpans,
       tree = tree != null ? tree : new TreeBuilder(true),
       tokenizer = (input is HtmlTokenizer ? input :
         new HtmlTokenizer(input, encoding: encoding, parseMeta: parseMeta,
           lowercaseElementName: lowercaseElementName,
           lowercaseAttrName: lowercaseAttrName,
           generateSpans: generateSpans, sourceUrl: sourceUrl)) {

   tokenizer.parser = this;
   _initialPhase = new InitialPhase(this);
   _beforeHtmlPhase = new BeforeHtmlPhase(this);
   _beforeHeadPhase = new BeforeHeadPhase(this);
   _inHeadPhase = new InHeadPhase(this);
   // TODO(jmesserly): html5lib did not implement the no script parsing mode
   // More information here:
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#scripting-flag
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-inheadnoscript
   // "inHeadNoscript": new InHeadNoScriptPhase(this);
   _afterHeadPhase = new AfterHeadPhase(this);
   _inBodyPhase = new InBodyPhase(this);
   _textPhase = new TextPhase(this);
   _inTablePhase = new InTablePhase(this);
   _inTableTextPhase = new InTableTextPhase(this);
   _inCaptionPhase = new InCaptionPhase(this);
   _inColumnGroupPhase = new InColumnGroupPhase(this);
   _inTableBodyPhase = new InTableBodyPhase(this);
   _inRowPhase = new InRowPhase(this);
   _inCellPhase = new InCellPhase(this);
   _inSelectPhase = new InSelectPhase(this);
   _inSelectInTablePhase = new InSelectInTablePhase(this);
   _inForeignContentPhase = new InForeignContentPhase(this);
   _afterBodyPhase = new AfterBodyPhase(this);
   _inFramesetPhase = new InFramesetPhase(this);
   _afterFramesetPhase = new AfterFramesetPhase(this);
   _afterAfterBodyPhase = new AfterAfterBodyPhase(this);
   _afterAfterFramesetPhase = new AfterAfterFramesetPhase(this);
 }

 bool get innerHTMLMode =&gt; innerHTML != null;

 /**
  * Parse an html5 document into a tree.
  * After parsing, [errors] will be populated with parse errors, if any.
  */
 Document parse() {
   innerHTML = null;
   _parse();
   return tree.getDocument();
 }

 /**
  * Parse an html5 document fragment into a tree.
  * Pass a [container] to change the type of the containing element.
  * After parsing, [errors] will be populated with parse errors, if any.
  */
 DocumentFragment parseFragment([String container = "div"]) {
   if (container == null) throw new ArgumentError('container');
   innerHTML = container.toLowerCase();
   _parse();
   return tree.getFragment();
 }

 void _parse() {
   reset();

   while (true) {
     try {
       mainLoop();
       break;
     } on ReparseException catch (e) {
       // Note: this happens if we start parsing but the character encoding
       // changes. So we should only need to restart very early in the parse.
       reset();
     }
   }
 }

 void reset() {
   tokenizer.reset();

   tree.reset();
   firstStartTag = false;
   errors.clear();
   // "quirks" / "limited quirks" / "no quirks"
   compatMode = "no quirks";

   if (innerHTMLMode) {
     if (cdataElements.contains(innerHTML)) {
       tokenizer.state = tokenizer.rcdataState;
     } else if (rcdataElements.contains(innerHTML)) {
       tokenizer.state = tokenizer.rawtextState;
     } else if (innerHTML == 'plaintext') {
       tokenizer.state = tokenizer.plaintextState;
     } else {
       // state already is data state
       // tokenizer.state = tokenizer.dataState;
     }
     phase = _beforeHtmlPhase;
     _beforeHtmlPhase.insertHtmlElement();
     resetInsertionMode();
   } else {
     phase = _initialPhase;
   }

   lastPhase = null;
   beforeRCDataPhase = null;
   framesetOK = true;
 }

 bool isHTMLIntegrationPoint(Node element) {
   if (element.tagName == "annotation-xml" &amp;&amp;
       element.namespace == Namespaces.mathml) {
     var enc = element.attributes["encoding"];
     if (enc != null) enc = asciiUpper2Lower(enc);
     return enc == "text/html" || enc == "application/xhtml+xml";
   } else {
     return htmlIntegrationPointElements.contains(
         new Pair(element.namespace, element.tagName));
   }
 }

 bool isMathMLTextIntegrationPoint(Node element) {
   return mathmlTextIntegrationPointElements.contains(
       new Pair(element.namespace, element.tagName));
 }

 bool inForeignContent(Token token, int type) {
   if (tree.openElements.length == 0) return false;

   var node = tree.openElements.last;
   if (node.namespace == tree.defaultNamespace) return false;

   if (isMathMLTextIntegrationPoint(node)) {
     if (type == TokenKind.startTag &amp;&amp;
         (token as StartTagToken).name != "mglyph" &amp;&amp;
         (token as StartTagToken).name != "malignmark")  {
       return false;
     }
     if (type == TokenKind.characters || type == TokenKind.spaceCharacters) {
       return false;
     }
   }

   if (node.tagName == "annotation-xml" &amp;&amp; type == TokenKind.startTag &amp;&amp;
       (token as StartTagToken).name == "svg") {
     return false;
   }

   if (isHTMLIntegrationPoint(node)) {
     if (type == TokenKind.startTag ||
         type == TokenKind.characters ||
         type == TokenKind.spaceCharacters) {
       return false;
     }
   }

   return true;
 }

 void mainLoop() {
   while (tokenizer.moveNext()) {
     var token = tokenizer.current;
     var newToken = token;
     int type;
     while (newToken != null) {
       type = newToken.kind;

       // Note: avoid "is" test here, see http://dartbug.com/4795
       if (type == TokenKind.parseError) {
         ParseErrorToken error = newToken;
         parseError(error.span, error.data, error.messageParams);
         newToken = null;
       } else {
         Phase phase_ = phase;
         if (inForeignContent(token, type)) {
           phase_ = _inForeignContentPhase;
         }

         switch (type) {
           case TokenKind.characters:
             newToken = phase_.processCharacters(newToken);
             break;
           case TokenKind.spaceCharacters:
             newToken = phase_.processSpaceCharacters(newToken);
             break;
           case TokenKind.startTag:
             newToken = phase_.processStartTag(newToken);
             break;
           case TokenKind.endTag:
             newToken = phase_.processEndTag(newToken);
             break;
           case TokenKind.comment:
             newToken = phase_.processComment(newToken);
             break;
           case TokenKind.doctype:
             newToken = phase_.processDoctype(newToken);
             break;
         }
       }
     }

     if (token is StartTagToken) {
       if (token.selfClosing &amp;&amp; !token.selfClosingAcknowledged) {
         parseError(token.span, "non-void-element-with-trailing-solidus",
             {"name": token.name});
       }
     }
   }

   // When the loop finishes it's EOF
   var reprocess = true;
   var reprocessPhases = [];
   while (reprocess) {
     reprocessPhases.add(phase);
     reprocess = phase.processEOF();
     if (reprocess) {
       assert(!reprocessPhases.contains(phase));
     }
   }
 }

 /**
  * The last span available. Used for EOF errors if we don't have something
  * better.
  */
 Span get _lastSpan {
   var pos = tokenizer.stream.position;
   return new FileSpan(tokenizer.stream.fileInfo, pos, pos);
 }

 void parseError(Span span, String errorcode,
     [Map datavars = const {}]) {

   if (!generateSpans &amp;&amp; span == null) {
     span = _lastSpan;
   }

   var err = new ParseError(errorcode, span, datavars);
   errors.add(err);
   if (strict) throw err;
 }

 void adjustMathMLAttributes(StartTagToken token) {
   var orig = token.data.remove("definitionurl");
   if (orig != null) {
     token.data["definitionURL"] = orig;
   }
 }

 void adjustSVGAttributes(StartTagToken token) {
   final replacements = const {
     "attributename":"attributeName",
     "attributetype":"attributeType",
     "basefrequency":"baseFrequency",
     "baseprofile":"baseProfile",
     "calcmode":"calcMode",
     "clippathunits":"clipPathUnits",
     "contentscripttype":"contentScriptType",
     "contentstyletype":"contentStyleType",
     "diffuseconstant":"diffuseConstant",
     "edgemode":"edgeMode",
     "externalresourcesrequired":"externalResourcesRequired",
     "filterres":"filterRes",
     "filterunits":"filterUnits",
     "glyphref":"glyphRef",
     "gradienttransform":"gradientTransform",
     "gradientunits":"gradientUnits",
     "kernelmatrix":"kernelMatrix",
     "kernelunitlength":"kernelUnitLength",
     "keypoints":"keyPoints",
     "keysplines":"keySplines",
     "keytimes":"keyTimes",
     "lengthadjust":"lengthAdjust",
     "limitingconeangle":"limitingConeAngle",
     "markerheight":"markerHeight",
     "markerunits":"markerUnits",
     "markerwidth":"markerWidth",
     "maskcontentunits":"maskContentUnits",
     "maskunits":"maskUnits",
     "numoctaves":"numOctaves",
     "pathlength":"pathLength",
     "patterncontentunits":"patternContentUnits",
     "patterntransform":"patternTransform",
     "patternunits":"patternUnits",
     "pointsatx":"pointsAtX",
     "pointsaty":"pointsAtY",
     "pointsatz":"pointsAtZ",
     "preservealpha":"preserveAlpha",
     "preserveaspectratio":"preserveAspectRatio",
     "primitiveunits":"primitiveUnits",
     "refx":"refX",
     "refy":"refY",
     "repeatcount":"repeatCount",
     "repeatdur":"repeatDur",
     "requiredextensions":"requiredExtensions",
     "requiredfeatures":"requiredFeatures",
     "specularconstant":"specularConstant",
     "specularexponent":"specularExponent",
     "spreadmethod":"spreadMethod",
     "startoffset":"startOffset",
     "stddeviation":"stdDeviation",
     "stitchtiles":"stitchTiles",
     "surfacescale":"surfaceScale",
     "systemlanguage":"systemLanguage",
     "tablevalues":"tableValues",
     "targetx":"targetX",
     "targety":"targetY",
     "textlength":"textLength",
     "viewbox":"viewBox",
     "viewtarget":"viewTarget",
     "xchannelselector":"xChannelSelector",
     "ychannelselector":"yChannelSelector",
     "zoomandpan":"zoomAndPan"
   };
   for (var originalName in token.data.keys.toList()) {
     var svgName = replacements[originalName];
     if (svgName != null) {
       token.data[svgName] = token.data.remove(originalName);
     }
   }
 }

 void adjustForeignAttributes(StartTagToken token) {
   // TODO(jmesserly): I don't like mixing non-string objects with strings in
   // the Node.attributes Map. Is there another solution?
   final replacements = const {
     "xlink:actuate": const AttributeName("xlink", "actuate",
           Namespaces.xlink),
     "xlink:arcrole": const AttributeName("xlink", "arcrole",
           Namespaces.xlink),
     "xlink:href": const AttributeName("xlink", "href", Namespaces.xlink),
     "xlink:role": const AttributeName("xlink", "role", Namespaces.xlink),
     "xlink:show": const AttributeName("xlink", "show", Namespaces.xlink),
     "xlink:title": const AttributeName("xlink", "title", Namespaces.xlink),
     "xlink:type": const AttributeName("xlink", "type", Namespaces.xlink),
     "xml:base": const AttributeName("xml", "base", Namespaces.xml),
     "xml:lang": const AttributeName("xml", "lang", Namespaces.xml),
     "xml:space": const AttributeName("xml", "space", Namespaces.xml),
     "xmlns": const AttributeName(null, "xmlns", Namespaces.xmlns),
     "xmlns:xlink": const AttributeName("xmlns", "xlink", Namespaces.xmlns)
   };

   for (var originalName in token.data.keys.toList()) {
     var foreignName = replacements[originalName];
     if (foreignName != null) {
       token.data[foreignName] = token.data.remove(originalName);
     }
   }
 }

 void resetInsertionMode() {
   // The name of this method is mostly historical. (It's also used in the
   // specification.)
   for (Node node in tree.openElements.reversed) {
     var nodeName = node.tagName;
     bool last = node == tree.openElements[0];
     if (last) {
       assert(innerHTMLMode);
       nodeName = innerHTML;
     }
     // Check for conditions that should only happen in the innerHTML
     // case
     switch (nodeName) {
       case "select": case "colgroup": case "head": case "html":
         assert(innerHTMLMode);
         break;
     }
     if (!last &amp;&amp; node.namespace != tree.defaultNamespace) {
       continue;
     }
     switch (nodeName) {
       case "select": phase = _inSelectPhase; return;
       case "td": phase = _inCellPhase; return;
       case "th": phase = _inCellPhase; return;
       case "tr": phase = _inRowPhase; return;
       case "tbody": phase = _inTableBodyPhase; return;
       case "thead": phase = _inTableBodyPhase; return;
       case "tfoot": phase = _inTableBodyPhase; return;
       case "caption": phase = _inCaptionPhase; return;
       case "colgroup": phase = _inColumnGroupPhase; return;
       case "table": phase = _inTablePhase; return;
       case "head": phase = _inBodyPhase; return;
       case "body": phase = _inBodyPhase; return;
       case "frameset": phase = _inFramesetPhase; return;
       case "html": phase = _beforeHeadPhase; return;
     }
   }
   phase = _inBodyPhase;
 }

 /**
  * Generic RCDATA/RAWTEXT Parsing algorithm
  * [contentType] - RCDATA or RAWTEXT
  */
 void parseRCDataRawtext(Token token, String contentType) {
   assert(contentType == "RAWTEXT" || contentType == "RCDATA");

   var element = tree.insertElement(token);

   if (contentType == "RAWTEXT") {
     tokenizer.state = tokenizer.rawtextState;
   } else {
     tokenizer.state = tokenizer.rcdataState;
   }

   originalPhase = phase;
   phase = _textPhase;
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>HtmlParser</strong>(input, {<a href="http://api.dartlang.org/dart_core/String.html">String</a> encoding, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> parseMeta: true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> lowercaseElementName: true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> lowercaseAttrName: true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> strict: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> generateSpans: false, <a href="http://api.dartlang.org/dart_core/String.html">String</a> sourceUrl, <a href="../treebuilder/TreeBuilder.html">TreeBuilder</a> tree}) <a class="anchor-link" href="#"
              title="Permalink to HtmlParser.HtmlParser">#</a></h4>
<div class="doc">
<p>Create a new HtmlParser and configure the 
<span class="param">tree</span> builder and 
<span class="param">strict</span> mode.
The 
<span class="param">input</span> can be a <a class="crossref" href="../dart_core/String.html">String</a>, [List<int>] of bytes or an <a class="crossref" href="../tokenizer/HtmlTokenizer.html">HtmlTokenizer</a>.</p>
<p>If 
<span class="param">input</span> is not a <a class="crossref" href="../tokenizer/HtmlTokenizer.html">HtmlTokenizer</a>, you can specify a few more arguments.</p>
<p>The 
<span class="param">encoding</span> must be a string that indicates the encoding. If specified,
that encoding will be used, regardless of any BOM or later declaration
(such as in a meta element).</p>
<p>Set 
<span class="param">parseMeta</span> to false if you want to disable parsing the meta element.</p>
<p>Set 
<span class="param">lowercaseElementName</span> or 
<span class="param">lowercaseAttrName</span> to false to disable the
automatic conversion of element and attribute names to lower case. Note
that standard way to parse HTML is to lowercase, which is what the browser
DOM will do if you request <code>Node.outerHTML</code>, for example.</p>
<pre class="source">
HtmlParser(input, {String encoding, bool parseMeta: true,
   bool lowercaseElementName: true, bool lowercaseAttrName: true,
   this.strict: false, bool generateSpans: false, String sourceUrl,
   TreeBuilder tree})
   : generateSpans = generateSpans,
     tree = tree != null ? tree : new TreeBuilder(true),
     tokenizer = (input is HtmlTokenizer ? input :
       new HtmlTokenizer(input, encoding: encoding, parseMeta: parseMeta,
         lowercaseElementName: lowercaseElementName,
         lowercaseAttrName: lowercaseAttrName,
         generateSpans: generateSpans, sourceUrl: sourceUrl)) {

 tokenizer.parser = this;
 _initialPhase = new InitialPhase(this);
 _beforeHtmlPhase = new BeforeHtmlPhase(this);
 _beforeHeadPhase = new BeforeHeadPhase(this);
 _inHeadPhase = new InHeadPhase(this);
 // TODO(jmesserly): html5lib did not implement the no script parsing mode
 // More information here:
 // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#scripting-flag
 // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-inheadnoscript
 // "inHeadNoscript": new InHeadNoScriptPhase(this);
 _afterHeadPhase = new AfterHeadPhase(this);
 _inBodyPhase = new InBodyPhase(this);
 _textPhase = new TextPhase(this);
 _inTablePhase = new InTablePhase(this);
 _inTableTextPhase = new InTableTextPhase(this);
 _inCaptionPhase = new InCaptionPhase(this);
 _inColumnGroupPhase = new InColumnGroupPhase(this);
 _inTableBodyPhase = new InTableBodyPhase(this);
 _inRowPhase = new InRowPhase(this);
 _inCellPhase = new InCellPhase(this);
 _inSelectPhase = new InSelectPhase(this);
 _inSelectInTablePhase = new InSelectInTablePhase(this);
 _inForeignContentPhase = new InForeignContentPhase(this);
 _afterBodyPhase = new AfterBodyPhase(this);
 _inFramesetPhase = new InFramesetPhase(this);
 _afterFramesetPhase = new AfterFramesetPhase(this);
 _afterAfterBodyPhase = new AfterAfterBodyPhase(this);
 _afterAfterFramesetPhase = new AfterAfterFramesetPhase(this);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="beforeRCDataPhase">
<button class="show-code">Code</button>
<a href="../parser/Phase.html">Phase</a>         <strong>beforeRCDataPhase</strong> <a class="anchor-link"
            href="#beforeRCDataPhase"
            title="Permalink to HtmlParser.beforeRCDataPhase">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Phase beforeRCDataPhase
</pre>
</div>
</div>
<div class="field"><h4 id="compatMode">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>compatMode</strong> <a class="anchor-link"
            href="#compatMode"
            title="Permalink to HtmlParser.compatMode">#</a>
        </h4>
        <div class="doc">
<p>"quirks" / "limited quirks" / "no quirks" </p>
<pre class="source">
String compatMode = "no quirks"
</pre>
</div>
</div>
<div class="field"><h4 id="container">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>container</strong> <a class="anchor-link"
            href="#container"
            title="Permalink to HtmlParser.container">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String container
</pre>
</div>
</div>
<div class="field"><h4 id="errors">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../parser/ParseError.html">ParseError</a>&gt;         <strong>errors</strong> <a class="anchor-link"
            href="#errors"
            title="Permalink to HtmlParser.errors">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final List&lt;ParseError&gt; errors = &lt;ParseError&gt;[]
</pre>
</div>
</div>
<div class="field"><h4 id="firstStartTag">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>firstStartTag</strong> <a class="anchor-link"
            href="#firstStartTag"
            title="Permalink to HtmlParser.firstStartTag">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool firstStartTag = false
</pre>
</div>
</div>
<div class="field"><h4 id="framesetOK">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>framesetOK</strong> <a class="anchor-link"
            href="#framesetOK"
            title="Permalink to HtmlParser.framesetOK">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool framesetOK
</pre>
</div>
</div>
<div class="field"><h4 id="generateSpans">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>generateSpans</strong> <a class="anchor-link"
            href="#generateSpans"
            title="Permalink to HtmlParser.generateSpans">#</a>
        </h4>
        <div class="doc">
<p>True to generate <a class="crossref" href="../source_maps.span/Span.html">Span</a>s for the <code>Node.sourceSpan</code> property. </p>
<pre class="source">
final bool generateSpans
</pre>
</div>
</div>
<div class="field"><h4 id="innerHTML">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>innerHTML</strong> <a class="anchor-link"
            href="#innerHTML"
            title="Permalink to HtmlParser.innerHTML">#</a>
        </h4>
        <div class="doc">
<p>innerHTML container when parsing document fragment. </p>
<pre class="source">
String innerHTML
</pre>
</div>
</div>
<div class="field"><h4 id="innerHTMLMode">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>innerHTMLMode</strong> <a class="anchor-link"
            href="#innerHTMLMode"
            title="Permalink to HtmlParser.innerHTMLMode">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool get innerHTMLMode =&gt; innerHTML != null;
</pre>
</div>
</div>
<div class="field"><h4 id="lastPhase">
<button class="show-code">Code</button>
<a href="../parser/Phase.html">Phase</a>         <strong>lastPhase</strong> <a class="anchor-link"
            href="#lastPhase"
            title="Permalink to HtmlParser.lastPhase">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Phase lastPhase
</pre>
</div>
</div>
<div class="field"><h4 id="originalPhase">
<button class="show-code">Code</button>
<a href="../parser/Phase.html">Phase</a>         <strong>originalPhase</strong> <a class="anchor-link"
            href="#originalPhase"
            title="Permalink to HtmlParser.originalPhase">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Phase originalPhase
</pre>
</div>
</div>
<div class="field"><h4 id="phase">
<button class="show-code">Code</button>
<a href="../parser/Phase.html">Phase</a>         <strong>phase</strong> <a class="anchor-link"
            href="#phase"
            title="Permalink to HtmlParser.phase">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Phase phase
</pre>
</div>
</div>
<div class="field"><h4 id="strict">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>strict</strong> <a class="anchor-link"
            href="#strict"
            title="Permalink to HtmlParser.strict">#</a>
        </h4>
        <div class="doc">
<p>Raise an exception on the first error encountered. </p>
<pre class="source">
final bool strict
</pre>
</div>
</div>
<div class="field"><h4 id="tokenizer">
<button class="show-code">Code</button>
final <a href="../tokenizer/HtmlTokenizer.html">HtmlTokenizer</a>         <strong>tokenizer</strong> <a class="anchor-link"
            href="#tokenizer"
            title="Permalink to HtmlParser.tokenizer">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final HtmlTokenizer tokenizer
</pre>
</div>
</div>
<div class="field"><h4 id="tree">
<button class="show-code">Code</button>
final <a href="../treebuilder/TreeBuilder.html">TreeBuilder</a>         <strong>tree</strong> <a class="anchor-link"
            href="#tree"
            title="Permalink to HtmlParser.tree">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final TreeBuilder tree
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="adjustForeignAttributes">
<button class="show-code">Code</button>
void <strong>adjustForeignAttributes</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#adjustForeignAttributes"
              title="Permalink to HtmlParser.adjustForeignAttributes">#</a></h4>
<div class="doc">
<pre class="source">
void adjustForeignAttributes(StartTagToken token) {
 // TODO(jmesserly): I don't like mixing non-string objects with strings in
 // the Node.attributes Map. Is there another solution?
 final replacements = const {
   "xlink:actuate": const AttributeName("xlink", "actuate",
         Namespaces.xlink),
   "xlink:arcrole": const AttributeName("xlink", "arcrole",
         Namespaces.xlink),
   "xlink:href": const AttributeName("xlink", "href", Namespaces.xlink),
   "xlink:role": const AttributeName("xlink", "role", Namespaces.xlink),
   "xlink:show": const AttributeName("xlink", "show", Namespaces.xlink),
   "xlink:title": const AttributeName("xlink", "title", Namespaces.xlink),
   "xlink:type": const AttributeName("xlink", "type", Namespaces.xlink),
   "xml:base": const AttributeName("xml", "base", Namespaces.xml),
   "xml:lang": const AttributeName("xml", "lang", Namespaces.xml),
   "xml:space": const AttributeName("xml", "space", Namespaces.xml),
   "xmlns": const AttributeName(null, "xmlns", Namespaces.xmlns),
   "xmlns:xlink": const AttributeName("xmlns", "xlink", Namespaces.xmlns)
 };

 for (var originalName in token.data.keys.toList()) {
   var foreignName = replacements[originalName];
   if (foreignName != null) {
     token.data[foreignName] = token.data.remove(originalName);
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="adjustMathMLAttributes">
<button class="show-code">Code</button>
void <strong>adjustMathMLAttributes</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#adjustMathMLAttributes"
              title="Permalink to HtmlParser.adjustMathMLAttributes">#</a></h4>
<div class="doc">
<pre class="source">
void adjustMathMLAttributes(StartTagToken token) {
 var orig = token.data.remove("definitionurl");
 if (orig != null) {
   token.data["definitionURL"] = orig;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="adjustSVGAttributes">
<button class="show-code">Code</button>
void <strong>adjustSVGAttributes</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#adjustSVGAttributes"
              title="Permalink to HtmlParser.adjustSVGAttributes">#</a></h4>
<div class="doc">
<pre class="source">
void adjustSVGAttributes(StartTagToken token) {
 final replacements = const {
   "attributename":"attributeName",
   "attributetype":"attributeType",
   "basefrequency":"baseFrequency",
   "baseprofile":"baseProfile",
   "calcmode":"calcMode",
   "clippathunits":"clipPathUnits",
   "contentscripttype":"contentScriptType",
   "contentstyletype":"contentStyleType",
   "diffuseconstant":"diffuseConstant",
   "edgemode":"edgeMode",
   "externalresourcesrequired":"externalResourcesRequired",
   "filterres":"filterRes",
   "filterunits":"filterUnits",
   "glyphref":"glyphRef",
   "gradienttransform":"gradientTransform",
   "gradientunits":"gradientUnits",
   "kernelmatrix":"kernelMatrix",
   "kernelunitlength":"kernelUnitLength",
   "keypoints":"keyPoints",
   "keysplines":"keySplines",
   "keytimes":"keyTimes",
   "lengthadjust":"lengthAdjust",
   "limitingconeangle":"limitingConeAngle",
   "markerheight":"markerHeight",
   "markerunits":"markerUnits",
   "markerwidth":"markerWidth",
   "maskcontentunits":"maskContentUnits",
   "maskunits":"maskUnits",
   "numoctaves":"numOctaves",
   "pathlength":"pathLength",
   "patterncontentunits":"patternContentUnits",
   "patterntransform":"patternTransform",
   "patternunits":"patternUnits",
   "pointsatx":"pointsAtX",
   "pointsaty":"pointsAtY",
   "pointsatz":"pointsAtZ",
   "preservealpha":"preserveAlpha",
   "preserveaspectratio":"preserveAspectRatio",
   "primitiveunits":"primitiveUnits",
   "refx":"refX",
   "refy":"refY",
   "repeatcount":"repeatCount",
   "repeatdur":"repeatDur",
   "requiredextensions":"requiredExtensions",
   "requiredfeatures":"requiredFeatures",
   "specularconstant":"specularConstant",
   "specularexponent":"specularExponent",
   "spreadmethod":"spreadMethod",
   "startoffset":"startOffset",
   "stddeviation":"stdDeviation",
   "stitchtiles":"stitchTiles",
   "surfacescale":"surfaceScale",
   "systemlanguage":"systemLanguage",
   "tablevalues":"tableValues",
   "targetx":"targetX",
   "targety":"targetY",
   "textlength":"textLength",
   "viewbox":"viewBox",
   "viewtarget":"viewTarget",
   "xchannelselector":"xChannelSelector",
   "ychannelselector":"yChannelSelector",
   "zoomandpan":"zoomAndPan"
 };
 for (var originalName in token.data.keys.toList()) {
   var svgName = replacements[originalName];
   if (svgName != null) {
     token.data[svgName] = token.data.remove(originalName);
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="inForeignContent">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>inForeignContent</strong>(<a href="../token/Token.html">Token</a> token, <a href="http://api.dartlang.org/dart_core/int.html">int</a> type) <a class="anchor-link" href="#inForeignContent"
              title="Permalink to HtmlParser.inForeignContent">#</a></h4>
<div class="doc">
<pre class="source">
bool inForeignContent(Token token, int type) {
 if (tree.openElements.length == 0) return false;

 var node = tree.openElements.last;
 if (node.namespace == tree.defaultNamespace) return false;

 if (isMathMLTextIntegrationPoint(node)) {
   if (type == TokenKind.startTag &amp;&amp;
       (token as StartTagToken).name != "mglyph" &amp;&amp;
       (token as StartTagToken).name != "malignmark")  {
     return false;
   }
   if (type == TokenKind.characters || type == TokenKind.spaceCharacters) {
     return false;
   }
 }

 if (node.tagName == "annotation-xml" &amp;&amp; type == TokenKind.startTag &amp;&amp;
     (token as StartTagToken).name == "svg") {
   return false;
 }

 if (isHTMLIntegrationPoint(node)) {
   if (type == TokenKind.startTag ||
       type == TokenKind.characters ||
       type == TokenKind.spaceCharacters) {
     return false;
   }
 }

 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isHTMLIntegrationPoint">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>isHTMLIntegrationPoint</strong>(<a href="../dom/Node.html">Node</a> element) <a class="anchor-link" href="#isHTMLIntegrationPoint"
              title="Permalink to HtmlParser.isHTMLIntegrationPoint">#</a></h4>
<div class="doc">
<pre class="source">
bool isHTMLIntegrationPoint(Node element) {
 if (element.tagName == "annotation-xml" &amp;&amp;
     element.namespace == Namespaces.mathml) {
   var enc = element.attributes["encoding"];
   if (enc != null) enc = asciiUpper2Lower(enc);
   return enc == "text/html" || enc == "application/xhtml+xml";
 } else {
   return htmlIntegrationPointElements.contains(
       new Pair(element.namespace, element.tagName));
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="isMathMLTextIntegrationPoint">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>isMathMLTextIntegrationPoint</strong>(<a href="../dom/Node.html">Node</a> element) <a class="anchor-link" href="#isMathMLTextIntegrationPoint"
              title="Permalink to HtmlParser.isMathMLTextIntegrationPoint">#</a></h4>
<div class="doc">
<pre class="source">
bool isMathMLTextIntegrationPoint(Node element) {
 return mathmlTextIntegrationPointElements.contains(
     new Pair(element.namespace, element.tagName));
}
</pre>
</div>
</div>
<div class="method"><h4 id="mainLoop">
<button class="show-code">Code</button>
void <strong>mainLoop</strong>() <a class="anchor-link" href="#mainLoop"
              title="Permalink to HtmlParser.mainLoop">#</a></h4>
<div class="doc">
<pre class="source">
void mainLoop() {
 while (tokenizer.moveNext()) {
   var token = tokenizer.current;
   var newToken = token;
   int type;
   while (newToken != null) {
     type = newToken.kind;

     // Note: avoid "is" test here, see http://dartbug.com/4795
     if (type == TokenKind.parseError) {
       ParseErrorToken error = newToken;
       parseError(error.span, error.data, error.messageParams);
       newToken = null;
     } else {
       Phase phase_ = phase;
       if (inForeignContent(token, type)) {
         phase_ = _inForeignContentPhase;
       }

       switch (type) {
         case TokenKind.characters:
           newToken = phase_.processCharacters(newToken);
           break;
         case TokenKind.spaceCharacters:
           newToken = phase_.processSpaceCharacters(newToken);
           break;
         case TokenKind.startTag:
           newToken = phase_.processStartTag(newToken);
           break;
         case TokenKind.endTag:
           newToken = phase_.processEndTag(newToken);
           break;
         case TokenKind.comment:
           newToken = phase_.processComment(newToken);
           break;
         case TokenKind.doctype:
           newToken = phase_.processDoctype(newToken);
           break;
       }
     }
   }

   if (token is StartTagToken) {
     if (token.selfClosing &amp;&amp; !token.selfClosingAcknowledged) {
       parseError(token.span, "non-void-element-with-trailing-solidus",
           {"name": token.name});
     }
   }
 }

 // When the loop finishes it's EOF
 var reprocess = true;
 var reprocessPhases = [];
 while (reprocess) {
   reprocessPhases.add(phase);
   reprocess = phase.processEOF();
   if (reprocess) {
     assert(!reprocessPhases.contains(phase));
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="parse">
<button class="show-code">Code</button>
<a href="../dom/Document.html">Document</a> <strong>parse</strong>() <a class="anchor-link" href="#parse"
              title="Permalink to HtmlParser.parse">#</a></h4>
<div class="doc">
<p>Parse an html5 document into a tree.
After parsing, <a class="crossref" href="../parser/HtmlParser.html#errors">errors</a> will be populated with parse errors, if any.</p>
<pre class="source">
Document parse() {
 innerHTML = null;
 _parse();
 return tree.getDocument();
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseError">
<button class="show-code">Code</button>
void <strong>parseError</strong>(<a href="../source_maps.span/Span.html">Span</a> span, <a href="http://api.dartlang.org/dart_core/String.html">String</a> errorcode, [<a href="http://api.dartlang.org/dart_core/Map.html">Map</a> datavars = const{}]) <a class="anchor-link" href="#parseError"
              title="Permalink to HtmlParser.parseError">#</a></h4>
<div class="doc">
<pre class="source">
void parseError(Span span, String errorcode,
   [Map datavars = const {}]) {

 if (!generateSpans &amp;&amp; span == null) {
   span = _lastSpan;
 }

 var err = new ParseError(errorcode, span, datavars);
 errors.add(err);
 if (strict) throw err;
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseFragment">
<button class="show-code">Code</button>
<a href="../dom/DocumentFragment.html">DocumentFragment</a> <strong>parseFragment</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> container = "div"]) <a class="anchor-link" href="#parseFragment"
              title="Permalink to HtmlParser.parseFragment">#</a></h4>
<div class="doc">
<p>Parse an html5 document fragment into a tree.
Pass a 
<span class="param">container</span> to change the type of the containing element.
After parsing, <a class="crossref" href="../parser/HtmlParser.html#errors">errors</a> will be populated with parse errors, if any.</p>
<pre class="source">
DocumentFragment parseFragment([String container = "div"]) {
 if (container == null) throw new ArgumentError('container');
 innerHTML = container.toLowerCase();
 _parse();
 return tree.getFragment();
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseRCDataRawtext">
<button class="show-code">Code</button>
void <strong>parseRCDataRawtext</strong>(<a href="../token/Token.html">Token</a> token, <a href="http://api.dartlang.org/dart_core/String.html">String</a> contentType) <a class="anchor-link" href="#parseRCDataRawtext"
              title="Permalink to HtmlParser.parseRCDataRawtext">#</a></h4>
<div class="doc">
<p>Generic RCDATA/RAWTEXT Parsing algorithm

<span class="param">contentType</span> - RCDATA or RAWTEXT</p>
<pre class="source">
void parseRCDataRawtext(Token token, String contentType) {
 assert(contentType == "RAWTEXT" || contentType == "RCDATA");

 var element = tree.insertElement(token);

 if (contentType == "RAWTEXT") {
   tokenizer.state = tokenizer.rawtextState;
 } else {
   tokenizer.state = tokenizer.rcdataState;
 }

 originalPhase = phase;
 phase = _textPhase;
}
</pre>
</div>
</div>
<div class="method"><h4 id="reset">
<button class="show-code">Code</button>
void <strong>reset</strong>() <a class="anchor-link" href="#reset"
              title="Permalink to HtmlParser.reset">#</a></h4>
<div class="doc">
<pre class="source">
void reset() {
 tokenizer.reset();

 tree.reset();
 firstStartTag = false;
 errors.clear();
 // "quirks" / "limited quirks" / "no quirks"
 compatMode = "no quirks";

 if (innerHTMLMode) {
   if (cdataElements.contains(innerHTML)) {
     tokenizer.state = tokenizer.rcdataState;
   } else if (rcdataElements.contains(innerHTML)) {
     tokenizer.state = tokenizer.rawtextState;
   } else if (innerHTML == 'plaintext') {
     tokenizer.state = tokenizer.plaintextState;
   } else {
     // state already is data state
     // tokenizer.state = tokenizer.dataState;
   }
   phase = _beforeHtmlPhase;
   _beforeHtmlPhase.insertHtmlElement();
   resetInsertionMode();
 } else {
   phase = _initialPhase;
 }

 lastPhase = null;
 beforeRCDataPhase = null;
 framesetOK = true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="resetInsertionMode">
<button class="show-code">Code</button>
void <strong>resetInsertionMode</strong>() <a class="anchor-link" href="#resetInsertionMode"
              title="Permalink to HtmlParser.resetInsertionMode">#</a></h4>
<div class="doc">
<pre class="source">
void resetInsertionMode() {
 // The name of this method is mostly historical. (It's also used in the
 // specification.)
 for (Node node in tree.openElements.reversed) {
   var nodeName = node.tagName;
   bool last = node == tree.openElements[0];
   if (last) {
     assert(innerHTMLMode);
     nodeName = innerHTML;
   }
   // Check for conditions that should only happen in the innerHTML
   // case
   switch (nodeName) {
     case "select": case "colgroup": case "head": case "html":
       assert(innerHTMLMode);
       break;
   }
   if (!last &amp;&amp; node.namespace != tree.defaultNamespace) {
     continue;
   }
   switch (nodeName) {
     case "select": phase = _inSelectPhase; return;
     case "td": phase = _inCellPhase; return;
     case "th": phase = _inCellPhase; return;
     case "tr": phase = _inRowPhase; return;
     case "tbody": phase = _inTableBodyPhase; return;
     case "thead": phase = _inTableBodyPhase; return;
     case "tfoot": phase = _inTableBodyPhase; return;
     case "caption": phase = _inCaptionPhase; return;
     case "colgroup": phase = _inColumnGroupPhase; return;
     case "table": phase = _inTablePhase; return;
     case "head": phase = _inBodyPhase; return;
     case "body": phase = _inBodyPhase; return;
     case "frameset": phase = _inFramesetPhase; return;
     case "html": phase = _beforeHeadPhase; return;
   }
 }
 phase = _inBodyPhase;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
