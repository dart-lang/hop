        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>InBodyPhase class / parser Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="parser" data-type="InBodyPhase">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../parser.html">parser</a> &rsaquo; <a href="../parser/InBodyPhase.html">InBodyPhase</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>InBodyPhase</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class InBodyPhase extends Phase {
 bool dropNewline = false;

 // http://www.whatwg.org/specs/web-apps/current-work///parsing-main-inbody
 // the really-really-really-very crazy mode
 InBodyPhase(parser) : super(parser);

 processStartTag(StartTagToken token) {
   switch (token.name) {
     case "html":
       return startTagHtml(token);
     case "base": case "basefont": case "bgsound": case "command": case "link":
     case "meta": case "noframes": case "script": case "style": case "title":
       return startTagProcessInHead(token);
     case "body":
       return startTagBody(token);
     case "frameset":
       return startTagFrameset(token);
     case "address": case "article": case "aside": case "blockquote":
     case "center": case "details": case "details": case "dir": case "div":
     case "dl": case "fieldset": case "figcaption": case "figure":
     case "footer": case "header": case "hgroup": case "menu": case "nav":
     case "ol": case "p": case "section": case "summary": case "ul":
       return startTagCloseP(token);
     // headingElements
     case "h1": case "h2": case "h3": case "h4": case "h5": case "h6":
       return startTagHeading(token);
     case "pre": case "listing":
       return startTagPreListing(token);
     case "form":
       return startTagForm(token);
     case "li": case "dd": case "dt":
       return startTagListItem(token);
     case "plaintext":
       return startTagPlaintext(token);
     case "a": return startTagA(token);
     case "b": case "big": case "code": case "em": case "font": case "i":
     case "s": case "small": case "strike": case "strong": case "tt": case "u":
       return startTagFormatting(token);
     case "nobr":
       return startTagNobr(token);
     case "button":
       return startTagButton(token);
     case "applet": case "marquee": case "object":
       return startTagAppletMarqueeObject(token);
     case "xmp":
       return startTagXmp(token);
     case "table":
       return startTagTable(token);
     case "area": case "br": case "embed": case "img": case "keygen":
     case "wbr":
       return startTagVoidFormatting(token);
     case "param": case "source": case "track":
       return startTagParamSource(token);
     case "input":
       return startTagInput(token);
     case "hr":
       return startTagHr(token);
     case "image":
       return startTagImage(token);
     case "isindex":
       return startTagIsIndex(token);
     case "textarea":
       return startTagTextarea(token);
     case "iframe":
       return startTagIFrame(token);
     case "noembed": case "noframes": case "noscript":
       return startTagRawtext(token);
     case "select":
       return startTagSelect(token);
     case "rp": case "rt":
       return startTagRpRt(token);
     case "option": case "optgroup":
       return startTagOpt(token);
     case "math":
       return startTagMath(token);
     case "svg":
       return startTagSvg(token);
     case "caption": case "col": case "colgroup": case "frame": case "head":
     case "tbody": case "td": case "tfoot": case "th": case "thead": case "tr":
       return startTagMisplaced(token);
     default: return startTagOther(token);
   }
 }

 processEndTag(EndTagToken token) {
   switch (token.name) {
     case "body": return endTagBody(token);
     case "html": return endTagHtml(token);
     case "address": case "article": case "aside": case "blockquote":
     case "center": case "details": case "dir": case "div": case "dl":
     case "fieldset": case "figcaption": case "figure": case "footer":
     case "header": case "hgroup": case "listing": case "menu": case "nav":
     case "ol": case "pre": case "section": case "summary": case "ul":
       return endTagBlock(token);
     case "form": return endTagForm(token);
     case "p": return endTagP(token);
     case "dd": case "dt": case "li": return endTagListItem(token);
     // headingElements
     case "h1": case "h2": case "h3": case "h4": case "h5": case "h6":
       return endTagHeading(token);
     case "a": case "b": case "big": case "code": case "em": case "font":
     case "i": case "nobr": case "s": case "small": case "strike":
     case "strong": case "tt": case "u":
       return endTagFormatting(token);
     case "applet": case "marquee": case "object":
       return endTagAppletMarqueeObject(token);
     case "br": return endTagBr(token);
       default: return endTagOther(token);
   }
 }

 bool isMatchingFormattingElement(Node node1, Node node2) {
   if (node1.tagName != node2.tagName || node1.namespace != node2.namespace) {
     return false;
   } else if (node1.attributes.length != node2.attributes.length) {
     return false;
   } else {
     for (var key in node1.attributes.keys) {
       if (node1.attributes[key] != node2.attributes[key]) {
         return false;
       }
     }
   }
   return true;
 }

 // helper
 void addFormattingElement(token) {
   tree.insertElement(token);
   var element = tree.openElements.last;

   var matchingElements = [];
   for (Node node in tree.activeFormattingElements.reversed) {
     if (node == Marker) {
       break;
     } else if (isMatchingFormattingElement(node, element)) {
       matchingElements.add(node);
     }
   }

   assert(matchingElements.length &lt;= 3);
   if (matchingElements.length == 3) {
     tree.activeFormattingElements.remove(matchingElements.last);
   }
   tree.activeFormattingElements.add(element);
 }

 // the real deal
 bool processEOF() {
   for (Node node in tree.openElements.reversed) {
     switch (node.tagName) {
       case "dd": case "dt": case "li": case "p": case "tbody": case "td":
       case "tfoot": case "th": case "thead": case "tr": case "body":
       case "html":
         continue;
     }
     parser.parseError(node.sourceSpan, "expected-closing-tag-but-got-eof");
     break;
   }
   //Stop parsing
   return false;
 }

 void processSpaceCharactersDropNewline(StringToken token) {
   // Sometimes (start of &lt;pre&gt;, &lt;listing&gt;, and &lt;textarea&gt; blocks) we
   // want to drop leading newlines
   var data = token.data;
   dropNewline = false;
   if (data.startsWith("\n")) {
     var lastOpen = tree.openElements.last;
     if (const ["pre", "listing", "textarea"].contains(lastOpen.tagName)
         &amp;&amp; !lastOpen.hasContent()) {
       data = data.substring(1);
     }
   }
   if (data.length &gt; 0) {
     tree.reconstructActiveFormattingElements();
     tree.insertText(data, token.span);
   }
 }

 Token processCharacters(CharactersToken token) {
   if (token.data == "\u0000") {
     //The tokenizer should always emit null on its own
     return null;
   }
   tree.reconstructActiveFormattingElements();
   tree.insertText(token.data, token.span);
   if (parser.framesetOK &amp;&amp; !allWhitespace(token.data)) {
     parser.framesetOK = false;
   }
   return null;
 }

 Token processSpaceCharacters(SpaceCharactersToken token) {
   if (dropNewline) {
     processSpaceCharactersDropNewline(token);
   } else {
     tree.reconstructActiveFormattingElements();
     tree.insertText(token.data, token.span);
   }
   return null;
 }

 Token startTagProcessInHead(StartTagToken token) {
   return parser._inHeadPhase.processStartTag(token);
 }

 void startTagBody(StartTagToken token) {
   parser.parseError(token.span, "unexpected-start-tag", {"name": "body"});
   if (tree.openElements.length == 1
       || tree.openElements[1].tagName != "body") {
     assert(parser.innerHTMLMode);
   } else {
     parser.framesetOK = false;
     token.data.forEach((attr, value) {
       tree.openElements[1].attributes.putIfAbsent(attr, () =&gt; value);
     });
   }
 }

 void startTagFrameset(StartTagToken token) {
   parser.parseError(token.span, "unexpected-start-tag", {"name": "frameset"});
   if ((tree.openElements.length == 1 ||
       tree.openElements[1].tagName != "body")) {
     assert(parser.innerHTMLMode);
   } else if (parser.framesetOK) {
     if (tree.openElements[1].parent != null) {
       tree.openElements[1].parent.nodes.remove(tree.openElements[1]);
     }
     while (tree.openElements.last.tagName != "html") {
       tree.openElements.removeLast();
     }
     tree.insertElement(token);
     parser.phase = parser._inFramesetPhase;
   }
 }

 void startTagCloseP(StartTagToken token) {
   if (tree.elementInScope("p", variant: "button")) {
     endTagP(new EndTagToken("p"));
   }
   tree.insertElement(token);
 }

 void startTagPreListing(StartTagToken token) {
   if (tree.elementInScope("p", variant: "button")) {
     endTagP(new EndTagToken("p"));
   }
   tree.insertElement(token);
   parser.framesetOK = false;
   dropNewline = true;
 }

 void startTagForm(StartTagToken token) {
   if (tree.formPointer != null) {
     parser.parseError(token.span, "unexpected-start-tag", {"name": "form"});
   } else {
     if (tree.elementInScope("p", variant: "button")) {
       endTagP(new EndTagToken("p"));
     }
     tree.insertElement(token);
     tree.formPointer = tree.openElements.last;
   }
 }

 void startTagListItem(StartTagToken token) {
   parser.framesetOK = false;

   final stopNamesMap = const {"li": const ["li"],
                               "dt": const ["dt", "dd"],
                               "dd": const ["dt", "dd"]};
   var stopNames = stopNamesMap[token.name];
   for (Node node in tree.openElements.reversed) {
     if (stopNames.contains(node.tagName)) {
       parser.phase.processEndTag(new EndTagToken(node.tagName));
       break;
     }
     if (specialElements.contains(node.nameTuple) &amp;&amp;
         !const ["address", "div", "p"].contains(node.tagName)) {
       break;
     }
   }

   if (tree.elementInScope("p", variant: "button")) {
     parser.phase.processEndTag(new EndTagToken("p"));
   }

   tree.insertElement(token);
 }

 void startTagPlaintext(StartTagToken token) {
   if (tree.elementInScope("p", variant: "button")) {
     endTagP(new EndTagToken("p"));
   }
   tree.insertElement(token);
   parser.tokenizer.state = parser.tokenizer.plaintextState;
 }

 void startTagHeading(StartTagToken token) {
   if (tree.elementInScope("p", variant: "button")) {
     endTagP(new EndTagToken("p"));
   }
   if (headingElements.contains(tree.openElements.last.tagName)) {
     parser.parseError(token.span, "unexpected-start-tag",
         {"name": token.name});
     tree.openElements.removeLast();
   }
   tree.insertElement(token);
 }

 void startTagA(StartTagToken token) {
   var afeAElement = tree.elementInActiveFormattingElements("a");
   if (afeAElement != null) {
     parser.parseError(token.span, "unexpected-start-tag-implies-end-tag",
         {"startName": "a", "endName": "a"});
     endTagFormatting(new EndTagToken("a"));
     tree.openElements.remove(afeAElement);
     tree.activeFormattingElements.remove(afeAElement);
   }
   tree.reconstructActiveFormattingElements();
   addFormattingElement(token);
 }

 void startTagFormatting(StartTagToken token) {
   tree.reconstructActiveFormattingElements();
   addFormattingElement(token);
 }

 void startTagNobr(StartTagToken token) {
   tree.reconstructActiveFormattingElements();
   if (tree.elementInScope("nobr")) {
     parser.parseError(token.span, "unexpected-start-tag-implies-end-tag",
       {"startName": "nobr", "endName": "nobr"});
     processEndTag(new EndTagToken("nobr"));
     // XXX Need tests that trigger the following
     tree.reconstructActiveFormattingElements();
   }
   addFormattingElement(token);
 }

 Token startTagButton(StartTagToken token) {
   if (tree.elementInScope("button")) {
     parser.parseError(token.span, "unexpected-start-tag-implies-end-tag",
       {"startName": "button", "endName": "button"});
     processEndTag(new EndTagToken("button"));
     return token;
   } else {
     tree.reconstructActiveFormattingElements();
     tree.insertElement(token);
     parser.framesetOK = false;
   }
 }

 void startTagAppletMarqueeObject(StartTagToken token) {
   tree.reconstructActiveFormattingElements();
   tree.insertElement(token);
   tree.activeFormattingElements.add(Marker);
   parser.framesetOK = false;
 }

 void startTagXmp(StartTagToken token) {
   if (tree.elementInScope("p", variant: "button")) {
     endTagP(new EndTagToken("p"));
   }
   tree.reconstructActiveFormattingElements();
   parser.framesetOK = false;
   parser.parseRCDataRawtext(token, "RAWTEXT");
 }

 void startTagTable(StartTagToken token) {
   if (parser.compatMode != "quirks") {
     if (tree.elementInScope("p", variant: "button")) {
       processEndTag(new EndTagToken("p"));
     }
   }
   tree.insertElement(token);
   parser.framesetOK = false;
   parser.phase = parser._inTablePhase;
 }

 void startTagVoidFormatting(StartTagToken token) {
   tree.reconstructActiveFormattingElements();
   tree.insertElement(token);
   tree.openElements.removeLast();
   token.selfClosingAcknowledged = true;
   parser.framesetOK = false;
 }

 void startTagInput(StartTagToken token) {
   var savedFramesetOK = parser.framesetOK;
   startTagVoidFormatting(token);
   if (asciiUpper2Lower(token.data["type"]) == "hidden") {
     //input type=hidden doesn't change framesetOK
     parser.framesetOK = savedFramesetOK;
   }
 }

 void startTagParamSource(StartTagToken token) {
   tree.insertElement(token);
   tree.openElements.removeLast();
   token.selfClosingAcknowledged = true;
 }

 void startTagHr(StartTagToken token) {
   if (tree.elementInScope("p", variant: "button")) {
     endTagP(new EndTagToken("p"));
   }
   tree.insertElement(token);
   tree.openElements.removeLast();
   token.selfClosingAcknowledged = true;
   parser.framesetOK = false;
 }

 void startTagImage(StartTagToken token) {
   // No really...
   parser.parseError(token.span, "unexpected-start-tag-treated-as",
       {"originalName": "image", "newName": "img"});
   processStartTag(new StartTagToken("img", data: token.data,
       selfClosing: token.selfClosing));
 }

 void startTagIsIndex(StartTagToken token) {
   parser.parseError(token.span, "deprecated-tag", {"name": "isindex"});
   if (tree.formPointer != null) {
     return;
   }
   var formAttrs = {};
   var dataAction = token.data["action"];
   if (dataAction != null) {
     formAttrs["action"] = dataAction;
   }
   processStartTag(new StartTagToken("form", data: formAttrs));
   processStartTag(new StartTagToken("hr", data: {}));
   processStartTag(new StartTagToken("label", data: {}));
   // XXX Localization ...
   var prompt = token.data["prompt"];
   if (prompt == null) {
     prompt = "This is a searchable index. Enter search keywords: ";
   }
   processCharacters(new CharactersToken(prompt));
   var attributes = new LinkedHashMap.from(token.data);
   attributes.remove('action');
   attributes.remove('prompt');
   attributes["name"] = "isindex";
   processStartTag(new StartTagToken("input",
                   data: attributes, selfClosing: token.selfClosing));
   processEndTag(new EndTagToken("label"));
   processStartTag(new StartTagToken("hr", data: {}));
   processEndTag(new EndTagToken("form"));
 }

 void startTagTextarea(StartTagToken token) {
   tree.insertElement(token);
   parser.tokenizer.state = parser.tokenizer.rcdataState;
   dropNewline = true;
   parser.framesetOK = false;
 }

 void startTagIFrame(StartTagToken token) {
   parser.framesetOK = false;
   startTagRawtext(token);
 }

 /** iframe, noembed noframes, noscript(if scripting enabled). */
 void startTagRawtext(StartTagToken token) {
   parser.parseRCDataRawtext(token, "RAWTEXT");
 }

 void startTagOpt(StartTagToken token) {
   if (tree.openElements.last.tagName == "option") {
     parser.phase.processEndTag(new EndTagToken("option"));
   }
   tree.reconstructActiveFormattingElements();
   parser.tree.insertElement(token);
 }

 void startTagSelect(StartTagToken token) {
   tree.reconstructActiveFormattingElements();
   tree.insertElement(token);
   parser.framesetOK = false;

   if (parser._inTablePhase == parser.phase ||
       parser._inCaptionPhase == parser.phase ||
       parser._inColumnGroupPhase == parser.phase ||
       parser._inTableBodyPhase == parser.phase ||
       parser._inRowPhase == parser.phase ||
       parser._inCellPhase == parser.phase) {
     parser.phase = parser._inSelectInTablePhase;
   } else {
     parser.phase = parser._inSelectPhase;
   }
 }

 void startTagRpRt(StartTagToken token) {
   if (tree.elementInScope("ruby")) {
     tree.generateImpliedEndTags();
     var last = tree.openElements.last;
     if (last.tagName != "ruby") {
       parser.parseError(last.sourceSpan, 'undefined-error');
     }
   }
   tree.insertElement(token);
 }

 void startTagMath(StartTagToken token) {
   tree.reconstructActiveFormattingElements();
   parser.adjustMathMLAttributes(token);
   parser.adjustForeignAttributes(token);
   token.namespace = Namespaces.mathml;
   tree.insertElement(token);
   //Need to get the parse error right for the case where the token
   //has a namespace not equal to the xmlns attribute
   if (token.selfClosing) {
     tree.openElements.removeLast();
     token.selfClosingAcknowledged = true;
   }
 }

 void startTagSvg(StartTagToken token) {
   tree.reconstructActiveFormattingElements();
   parser.adjustSVGAttributes(token);
   parser.adjustForeignAttributes(token);
   token.namespace = Namespaces.svg;
   tree.insertElement(token);
   //Need to get the parse error right for the case where the token
   //has a namespace not equal to the xmlns attribute
   if (token.selfClosing) {
     tree.openElements.removeLast();
     token.selfClosingAcknowledged = true;
   }
 }

 /**
  * Elements that should be children of other elements that have a
  * different insertion mode; here they are ignored
  * "caption", "col", "colgroup", "frame", "frameset", "head",
  * "option", "optgroup", "tbody", "td", "tfoot", "th", "thead",
  * "tr", "noscript"
 */
 void startTagMisplaced(StartTagToken token) {
   parser.parseError(token.span, "unexpected-start-tag-ignored",
       {"name": token.name});
 }

 Token startTagOther(StartTagToken token) {
   tree.reconstructActiveFormattingElements();
   tree.insertElement(token);
 }

 void endTagP(EndTagToken token) {
   if (!tree.elementInScope("p", variant: "button")) {
     startTagCloseP(new StartTagToken("p", data: {}));
     parser.parseError(token.span, "unexpected-end-tag", {"name": "p"});
     endTagP(new EndTagToken("p"));
   } else {
     tree.generateImpliedEndTags("p");
     if (tree.openElements.last.tagName != "p") {
       parser.parseError(token.span, "unexpected-end-tag", {"name": "p"});
     }
     popOpenElementsUntil("p");
   }
 }

 void endTagBody(EndTagToken token) {
   if (!tree.elementInScope("body")) {
     parser.parseError(token.span, 'undefined-error');
     return;
   } else if (tree.openElements.last.tagName != "body") {
     for (Node node in slice(tree.openElements, 2)) {
       switch (node.tagName) {
         case "dd": case "dt": case "li": case "optgroup": case "option":
         case "p": case "rp": case "rt": case "tbody": case "td": case "tfoot":
         case "th": case "thead": case "tr": case "body": case "html":
           continue;
       }
       // Not sure this is the correct name for the parse error
       parser.parseError(token.span, "expected-one-end-tag-but-got-another",
           {"expectedName": "body", "gotName": node.tagName});
       break;
     }
   }
   parser.phase = parser._afterBodyPhase;
 }

 Token endTagHtml(EndTagToken token) {
   //We repeat the test for the body end tag token being ignored here
   if (tree.elementInScope("body")) {
     endTagBody(new EndTagToken("body"));
     return token;
   }
 }

 void endTagBlock(EndTagToken token) {
   //Put us back in the right whitespace handling mode
   if (token.name == "pre") {
     dropNewline = false;
   }
   var inScope = tree.elementInScope(token.name);
   if (inScope) {
     tree.generateImpliedEndTags();
   }
   if (tree.openElements.last.tagName != token.name) {
     parser.parseError(token.span, "end-tag-too-early", {"name": token.name});
   }
   if (inScope) {
     popOpenElementsUntil(token.name);
   }
 }

 void endTagForm(EndTagToken token) {
   var node = tree.formPointer;
   tree.formPointer = null;
   if (node == null || !tree.elementInScope(node)) {
     parser.parseError(token.span, "unexpected-end-tag", {"name": "form"});
   } else {
     tree.generateImpliedEndTags();
     if (tree.openElements.last != node) {
       parser.parseError(token.span, "end-tag-too-early-ignored", {"name": "form"});
     }
     tree.openElements.remove(node);
   }
 }

 void endTagListItem(EndTagToken token) {
   var variant;
   if (token.name == "li") {
     variant = "list";
   } else {
     variant = null;
   }
   if (!tree.elementInScope(token.name, variant: variant)) {
     parser.parseError(token.span, "unexpected-end-tag", {"name": token.name});
   } else {
     tree.generateImpliedEndTags(token.name);
     if (tree.openElements.last.tagName != token.name) {
       parser.parseError(token.span, "end-tag-too-early", {"name": token.name});
     }
     popOpenElementsUntil(token.name);
   }
 }

 void endTagHeading(EndTagToken token) {
   for (var item in headingElements) {
     if (tree.elementInScope(item)) {
       tree.generateImpliedEndTags();
       break;
     }
   }
   if (tree.openElements.last.tagName != token.name) {
     parser.parseError(token.span, "end-tag-too-early", {"name": token.name});
   }

   for (var item in headingElements) {
     if (tree.elementInScope(item)) {
       item = tree.openElements.removeLast();
       while (!headingElements.contains(item.tagName)) {
         item = tree.openElements.removeLast();
       }
       break;
     }
   }
 }

 /** The much-feared adoption agency algorithm. */
 endTagFormatting(EndTagToken token) {
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency
   // TODO(jmesserly): the comments here don't match the numbered steps in the
   // updated spec. This needs a pass over it to verify that it still matches.
   // In particular the html5lib Python code skiped "step 4", I'm not sure why.
   // XXX Better parseError messages appreciated.
   int outerLoopCounter = 0;
   while (outerLoopCounter &lt; 8) {
     outerLoopCounter += 1;

     // Step 1 paragraph 1
     var formattingElement = tree.elementInActiveFormattingElements(
         token.name);
     if (formattingElement == null ||
         (tree.openElements.contains(formattingElement) &amp;&amp;
          !tree.elementInScope(formattingElement.tagName))) {
       parser.parseError(token.span, "adoption-agency-1.1",
           {"name": token.name});
       return;
     // Step 1 paragraph 2
     } else if (!tree.openElements.contains(formattingElement)) {
       parser.parseError(token.span, "adoption-agency-1.2",
           {"name": token.name});
       tree.activeFormattingElements.remove(formattingElement);
       return;
     }

     // Step 1 paragraph 3
     if (formattingElement != tree.openElements.last) {
       parser.parseError(token.span, "adoption-agency-1.3",
           {"name": token.name});
     }

     // Step 2
     // Start of the adoption agency algorithm proper
     var afeIndex = tree.openElements.indexOf(formattingElement);
     Node furthestBlock = null;
     for (Node element in slice(tree.openElements, afeIndex)) {
       if (specialElements.contains(element.nameTuple)) {
         furthestBlock = element;
         break;
       }
     }
     // Step 3
     if (furthestBlock == null) {
       var element = tree.openElements.removeLast();
       while (element != formattingElement) {
         element = tree.openElements.removeLast();
       }
       tree.activeFormattingElements.remove(element);
       return;
     }

     var commonAncestor = tree.openElements[afeIndex - 1];

     // Step 5
     // The bookmark is supposed to help us identify where to reinsert
     // nodes in step 12. We have to ensure that we reinsert nodes after
     // the node before the active formatting element. Note the bookmark
     // can move in step 7.4
     var bookmark = tree.activeFormattingElements.indexOf(formattingElement);

     // Step 6
     Node lastNode = furthestBlock;
     var node = furthestBlock;
     int innerLoopCounter = 0;

     var index = tree.openElements.indexOf(node);
     while (innerLoopCounter &lt; 3) {
       innerLoopCounter += 1;

       // Node is element before node in open elements
       index -= 1;
       node = tree.openElements[index];
       if (!tree.activeFormattingElements.contains(node)) {
         tree.openElements.remove(node);
         continue;
       }
       // Step 6.3
       if (node == formattingElement) {
         break;
       }
       // Step 6.4
       if (lastNode == furthestBlock) {
         bookmark = (tree.activeFormattingElements.indexOf(node) + 1);
       }
       // Step 6.5
       //cite = node.parent
       var clone = node.clone();
       // Replace node with clone
       tree.activeFormattingElements[
           tree.activeFormattingElements.indexOf(node)] = clone;
       tree.openElements[tree.openElements.indexOf(node)] = clone;
       node = clone;

       // Step 6.6
       // Remove lastNode from its parents, if any
       if (lastNode.parent != null) {
         lastNode.parent.nodes.remove(lastNode);
       }
       node.nodes.add(lastNode);
       // Step 7.7
       lastNode = node;
       // End of inner loop
     }

     // Step 7
     // Foster parent lastNode if commonAncestor is a
     // table, tbody, tfoot, thead, or tr we need to foster parent the
     // lastNode
     if (lastNode.parent != null) {
       lastNode.parent.nodes.remove(lastNode);
     }

     if (const ["table", "tbody", "tfoot", "thead", "tr"].contains(
         commonAncestor.tagName)) {
       var nodePos = tree.getTableMisnestedNodePosition();
       nodePos[0].insertBefore(lastNode, nodePos[1]);
     } else {
       commonAncestor.nodes.add(lastNode);
     }

     // Step 8
     var clone = formattingElement.clone();

     // Step 9
     furthestBlock.reparentChildren(clone);

     // Step 10
     furthestBlock.nodes.add(clone);

     // Step 11
     tree.activeFormattingElements.remove(formattingElement);
     tree.activeFormattingElements.insert(
         min(bookmark, tree.activeFormattingElements.length), clone);

     // Step 12
     tree.openElements.remove(formattingElement);
     tree.openElements.insert(
         tree.openElements.indexOf(furthestBlock) + 1, clone);
   }
 }

 void endTagAppletMarqueeObject(EndTagToken token) {
   if (tree.elementInScope(token.name)) {
     tree.generateImpliedEndTags();
   }
   if (tree.openElements.last.tagName != token.name) {
     parser.parseError(token.span, "end-tag-too-early", {"name": token.name});
   }
   if (tree.elementInScope(token.name)) {
     popOpenElementsUntil(token.name);
     tree.clearActiveFormattingElements();
   }
 }

 void endTagBr(EndTagToken token) {
   parser.parseError(token.span, "unexpected-end-tag-treated-as",
       {"originalName": "br", "newName": "br element"});
   tree.reconstructActiveFormattingElements();
   tree.insertElement(new StartTagToken("br", data: {}));
   tree.openElements.removeLast();
 }

 void endTagOther(EndTagToken token) {
   for (Node node in tree.openElements.reversed) {
     if (node.tagName == token.name) {
       tree.generateImpliedEndTags(token.name);
       if (tree.openElements.last.tagName != token.name) {
         parser.parseError(token.span, "unexpected-end-tag",
             {"name": token.name});
       }
       while (tree.openElements.removeLast() != node);
       break;
     } else {
       if (specialElements.contains(node.nameTuple)) {
         parser.parseError(token.span, "unexpected-end-tag",
             {"name": token.name});
         break;
       }
     }
   }
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../parser/Phase.html">Phase</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>InBodyPhase</strong></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>InBodyPhase</strong>(parser) <a class="anchor-link" href="#"
              title="Permalink to InBodyPhase.InBodyPhase">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> </div></div>
<pre class="source">
InBodyPhase(parser) : super(parser);
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="dropNewline">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>dropNewline</strong> <a class="anchor-link"
            href="#dropNewline"
            title="Permalink to InBodyPhase.dropNewline">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool dropNewline = false
</pre>
</div>
</div>
<div class="field inherited"><h4 id="parser">
<button class="show-code">Code</button>
final <a href="../parser/HtmlParser.html">HtmlParser</a>         <strong>parser</strong> <a class="anchor-link"
            href="#parser"
            title="Permalink to InBodyPhase.parser">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../parser/Phase.html">Phase</a> </div><div class="doc">
<pre class="source">
final HtmlParser parser
</pre>
</div>
</div>
<div class="field inherited"><h4 id="tree">
<button class="show-code">Code</button>
final <a href="../treebuilder/TreeBuilder.html">TreeBuilder</a>         <strong>tree</strong> <a class="anchor-link"
            href="#tree"
            title="Permalink to InBodyPhase.tree">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../parser/Phase.html">Phase</a> </div><div class="doc">
<pre class="source">
final TreeBuilder tree
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="addFormattingElement">
<button class="show-code">Code</button>
void <strong>addFormattingElement</strong>(token) <a class="anchor-link" href="#addFormattingElement"
              title="Permalink to InBodyPhase.addFormattingElement">#</a></h4>
<div class="doc">
<pre class="source">
void addFormattingElement(token) {
 tree.insertElement(token);
 var element = tree.openElements.last;

 var matchingElements = [];
 for (Node node in tree.activeFormattingElements.reversed) {
   if (node == Marker) {
     break;
   } else if (isMatchingFormattingElement(node, element)) {
     matchingElements.add(node);
   }
 }

 assert(matchingElements.length &lt;= 3);
 if (matchingElements.length == 3) {
   tree.activeFormattingElements.remove(matchingElements.last);
 }
 tree.activeFormattingElements.add(element);
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagAppletMarqueeObject">
<button class="show-code">Code</button>
void <strong>endTagAppletMarqueeObject</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagAppletMarqueeObject"
              title="Permalink to InBodyPhase.endTagAppletMarqueeObject">#</a></h4>
<div class="doc">
<pre class="source">
void endTagAppletMarqueeObject(EndTagToken token) {
 if (tree.elementInScope(token.name)) {
   tree.generateImpliedEndTags();
 }
 if (tree.openElements.last.tagName != token.name) {
   parser.parseError(token.span, "end-tag-too-early", {"name": token.name});
 }
 if (tree.elementInScope(token.name)) {
   popOpenElementsUntil(token.name);
   tree.clearActiveFormattingElements();
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagBlock">
<button class="show-code">Code</button>
void <strong>endTagBlock</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagBlock"
              title="Permalink to InBodyPhase.endTagBlock">#</a></h4>
<div class="doc">
<pre class="source">
void endTagBlock(EndTagToken token) {
 //Put us back in the right whitespace handling mode
 if (token.name == "pre") {
   dropNewline = false;
 }
 var inScope = tree.elementInScope(token.name);
 if (inScope) {
   tree.generateImpliedEndTags();
 }
 if (tree.openElements.last.tagName != token.name) {
   parser.parseError(token.span, "end-tag-too-early", {"name": token.name});
 }
 if (inScope) {
   popOpenElementsUntil(token.name);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagBody">
<button class="show-code">Code</button>
void <strong>endTagBody</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagBody"
              title="Permalink to InBodyPhase.endTagBody">#</a></h4>
<div class="doc">
<pre class="source">
void endTagBody(EndTagToken token) {
 if (!tree.elementInScope("body")) {
   parser.parseError(token.span, 'undefined-error');
   return;
 } else if (tree.openElements.last.tagName != "body") {
   for (Node node in slice(tree.openElements, 2)) {
     switch (node.tagName) {
       case "dd": case "dt": case "li": case "optgroup": case "option":
       case "p": case "rp": case "rt": case "tbody": case "td": case "tfoot":
       case "th": case "thead": case "tr": case "body": case "html":
         continue;
     }
     // Not sure this is the correct name for the parse error
     parser.parseError(token.span, "expected-one-end-tag-but-got-another",
         {"expectedName": "body", "gotName": node.tagName});
     break;
   }
 }
 parser.phase = parser._afterBodyPhase;
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagBr">
<button class="show-code">Code</button>
void <strong>endTagBr</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagBr"
              title="Permalink to InBodyPhase.endTagBr">#</a></h4>
<div class="doc">
<pre class="source">
void endTagBr(EndTagToken token) {
 parser.parseError(token.span, "unexpected-end-tag-treated-as",
     {"originalName": "br", "newName": "br element"});
 tree.reconstructActiveFormattingElements();
 tree.insertElement(new StartTagToken("br", data: {}));
 tree.openElements.removeLast();
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagForm">
<button class="show-code">Code</button>
void <strong>endTagForm</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagForm"
              title="Permalink to InBodyPhase.endTagForm">#</a></h4>
<div class="doc">
<pre class="source">
void endTagForm(EndTagToken token) {
 var node = tree.formPointer;
 tree.formPointer = null;
 if (node == null || !tree.elementInScope(node)) {
   parser.parseError(token.span, "unexpected-end-tag", {"name": "form"});
 } else {
   tree.generateImpliedEndTags();
   if (tree.openElements.last != node) {
     parser.parseError(token.span, "end-tag-too-early-ignored", {"name": "form"});
   }
   tree.openElements.remove(node);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagFormatting">
<button class="show-code">Code</button>
dynamic <strong>endTagFormatting</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagFormatting"
              title="Permalink to InBodyPhase.endTagFormatting">#</a></h4>
<div class="doc">
<p>The much-feared adoption agency algorithm. </p>
<pre class="source">
endTagFormatting(EndTagToken token) {
 // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency
 // TODO(jmesserly): the comments here don't match the numbered steps in the
 // updated spec. This needs a pass over it to verify that it still matches.
 // In particular the html5lib Python code skiped "step 4", I'm not sure why.
 // XXX Better parseError messages appreciated.
 int outerLoopCounter = 0;
 while (outerLoopCounter &lt; 8) {
   outerLoopCounter += 1;

   // Step 1 paragraph 1
   var formattingElement = tree.elementInActiveFormattingElements(
       token.name);
   if (formattingElement == null ||
       (tree.openElements.contains(formattingElement) &amp;&amp;
        !tree.elementInScope(formattingElement.tagName))) {
     parser.parseError(token.span, "adoption-agency-1.1",
         {"name": token.name});
     return;
   // Step 1 paragraph 2
   } else if (!tree.openElements.contains(formattingElement)) {
     parser.parseError(token.span, "adoption-agency-1.2",
         {"name": token.name});
     tree.activeFormattingElements.remove(formattingElement);
     return;
   }

   // Step 1 paragraph 3
   if (formattingElement != tree.openElements.last) {
     parser.parseError(token.span, "adoption-agency-1.3",
         {"name": token.name});
   }

   // Step 2
   // Start of the adoption agency algorithm proper
   var afeIndex = tree.openElements.indexOf(formattingElement);
   Node furthestBlock = null;
   for (Node element in slice(tree.openElements, afeIndex)) {
     if (specialElements.contains(element.nameTuple)) {
       furthestBlock = element;
       break;
     }
   }
   // Step 3
   if (furthestBlock == null) {
     var element = tree.openElements.removeLast();
     while (element != formattingElement) {
       element = tree.openElements.removeLast();
     }
     tree.activeFormattingElements.remove(element);
     return;
   }

   var commonAncestor = tree.openElements[afeIndex - 1];

   // Step 5
   // The bookmark is supposed to help us identify where to reinsert
   // nodes in step 12. We have to ensure that we reinsert nodes after
   // the node before the active formatting element. Note the bookmark
   // can move in step 7.4
   var bookmark = tree.activeFormattingElements.indexOf(formattingElement);

   // Step 6
   Node lastNode = furthestBlock;
   var node = furthestBlock;
   int innerLoopCounter = 0;

   var index = tree.openElements.indexOf(node);
   while (innerLoopCounter &lt; 3) {
     innerLoopCounter += 1;

     // Node is element before node in open elements
     index -= 1;
     node = tree.openElements[index];
     if (!tree.activeFormattingElements.contains(node)) {
       tree.openElements.remove(node);
       continue;
     }
     // Step 6.3
     if (node == formattingElement) {
       break;
     }
     // Step 6.4
     if (lastNode == furthestBlock) {
       bookmark = (tree.activeFormattingElements.indexOf(node) + 1);
     }
     // Step 6.5
     //cite = node.parent
     var clone = node.clone();
     // Replace node with clone
     tree.activeFormattingElements[
         tree.activeFormattingElements.indexOf(node)] = clone;
     tree.openElements[tree.openElements.indexOf(node)] = clone;
     node = clone;

     // Step 6.6
     // Remove lastNode from its parents, if any
     if (lastNode.parent != null) {
       lastNode.parent.nodes.remove(lastNode);
     }
     node.nodes.add(lastNode);
     // Step 7.7
     lastNode = node;
     // End of inner loop
   }

   // Step 7
   // Foster parent lastNode if commonAncestor is a
   // table, tbody, tfoot, thead, or tr we need to foster parent the
   // lastNode
   if (lastNode.parent != null) {
     lastNode.parent.nodes.remove(lastNode);
   }

   if (const ["table", "tbody", "tfoot", "thead", "tr"].contains(
       commonAncestor.tagName)) {
     var nodePos = tree.getTableMisnestedNodePosition();
     nodePos[0].insertBefore(lastNode, nodePos[1]);
   } else {
     commonAncestor.nodes.add(lastNode);
   }

   // Step 8
   var clone = formattingElement.clone();

   // Step 9
   furthestBlock.reparentChildren(clone);

   // Step 10
   furthestBlock.nodes.add(clone);

   // Step 11
   tree.activeFormattingElements.remove(formattingElement);
   tree.activeFormattingElements.insert(
       min(bookmark, tree.activeFormattingElements.length), clone);

   // Step 12
   tree.openElements.remove(formattingElement);
   tree.openElements.insert(
       tree.openElements.indexOf(furthestBlock) + 1, clone);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagHeading">
<button class="show-code">Code</button>
void <strong>endTagHeading</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagHeading"
              title="Permalink to InBodyPhase.endTagHeading">#</a></h4>
<div class="doc">
<pre class="source">
void endTagHeading(EndTagToken token) {
 for (var item in headingElements) {
   if (tree.elementInScope(item)) {
     tree.generateImpliedEndTags();
     break;
   }
 }
 if (tree.openElements.last.tagName != token.name) {
   parser.parseError(token.span, "end-tag-too-early", {"name": token.name});
 }

 for (var item in headingElements) {
   if (tree.elementInScope(item)) {
     item = tree.openElements.removeLast();
     while (!headingElements.contains(item.tagName)) {
       item = tree.openElements.removeLast();
     }
     break;
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagHtml">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>endTagHtml</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagHtml"
              title="Permalink to InBodyPhase.endTagHtml">#</a></h4>
<div class="doc">
<pre class="source">
Token endTagHtml(EndTagToken token) {
 //We repeat the test for the body end tag token being ignored here
 if (tree.elementInScope("body")) {
   endTagBody(new EndTagToken("body"));
   return token;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagListItem">
<button class="show-code">Code</button>
void <strong>endTagListItem</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagListItem"
              title="Permalink to InBodyPhase.endTagListItem">#</a></h4>
<div class="doc">
<pre class="source">
void endTagListItem(EndTagToken token) {
 var variant;
 if (token.name == "li") {
   variant = "list";
 } else {
   variant = null;
 }
 if (!tree.elementInScope(token.name, variant: variant)) {
   parser.parseError(token.span, "unexpected-end-tag", {"name": token.name});
 } else {
   tree.generateImpliedEndTags(token.name);
   if (tree.openElements.last.tagName != token.name) {
     parser.parseError(token.span, "end-tag-too-early", {"name": token.name});
   }
   popOpenElementsUntil(token.name);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagOther">
<button class="show-code">Code</button>
void <strong>endTagOther</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagOther"
              title="Permalink to InBodyPhase.endTagOther">#</a></h4>
<div class="doc">
<pre class="source">
void endTagOther(EndTagToken token) {
 for (Node node in tree.openElements.reversed) {
   if (node.tagName == token.name) {
     tree.generateImpliedEndTags(token.name);
     if (tree.openElements.last.tagName != token.name) {
       parser.parseError(token.span, "unexpected-end-tag",
           {"name": token.name});
     }
     while (tree.openElements.removeLast() != node);
     break;
   } else {
     if (specialElements.contains(node.nameTuple)) {
       parser.parseError(token.span, "unexpected-end-tag",
           {"name": token.name});
       break;
     }
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="endTagP">
<button class="show-code">Code</button>
void <strong>endTagP</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#endTagP"
              title="Permalink to InBodyPhase.endTagP">#</a></h4>
<div class="doc">
<pre class="source">
void endTagP(EndTagToken token) {
 if (!tree.elementInScope("p", variant: "button")) {
   startTagCloseP(new StartTagToken("p", data: {}));
   parser.parseError(token.span, "unexpected-end-tag", {"name": "p"});
   endTagP(new EndTagToken("p"));
 } else {
   tree.generateImpliedEndTags("p");
   if (tree.openElements.last.tagName != "p") {
     parser.parseError(token.span, "unexpected-end-tag", {"name": "p"});
   }
   popOpenElementsUntil("p");
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="isMatchingFormattingElement">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>isMatchingFormattingElement</strong>(<a href="../dom/Node.html">Node</a> node1, <a href="../dom/Node.html">Node</a> node2) <a class="anchor-link" href="#isMatchingFormattingElement"
              title="Permalink to InBodyPhase.isMatchingFormattingElement">#</a></h4>
<div class="doc">
<pre class="source">
bool isMatchingFormattingElement(Node node1, Node node2) {
 if (node1.tagName != node2.tagName || node1.namespace != node2.namespace) {
   return false;
 } else if (node1.attributes.length != node2.attributes.length) {
   return false;
 } else {
   for (var key in node1.attributes.keys) {
     if (node1.attributes[key] != node2.attributes[key]) {
       return false;
     }
   }
 }
 return true;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="popOpenElementsUntil">
<button class="show-code">Code</button>
void <strong>popOpenElementsUntil</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> name) <a class="anchor-link" href="#popOpenElementsUntil"
              title="Permalink to InBodyPhase.popOpenElementsUntil">#</a></h4>
<div class="inherited-from">inherited from <a href="../parser/Phase.html">Phase</a> </div><div class="doc">
<p>Helper method for popping openElements. </p>
<pre class="source">
void popOpenElementsUntil(String name) {
 var node = tree.openElements.removeLast();
 while (node.tagName != name) {
   node = tree.openElements.removeLast();
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="processCharacters">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>processCharacters</strong>(<a href="../token/CharactersToken.html">CharactersToken</a> token) <a class="anchor-link" href="#processCharacters"
              title="Permalink to InBodyPhase.processCharacters">#</a></h4>
<div class="doc">
<pre class="source">
Token processCharacters(CharactersToken token) {
 if (token.data == "\u0000") {
   //The tokenizer should always emit null on its own
   return null;
 }
 tree.reconstructActiveFormattingElements();
 tree.insertText(token.data, token.span);
 if (parser.framesetOK &amp;&amp; !allWhitespace(token.data)) {
   parser.framesetOK = false;
 }
 return null;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="processComment">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>processComment</strong>(<a href="../token/CommentToken.html">CommentToken</a> token) <a class="anchor-link" href="#processComment"
              title="Permalink to InBodyPhase.processComment">#</a></h4>
<div class="inherited-from">inherited from <a href="../parser/Phase.html">Phase</a> </div><div class="doc">
<pre class="source">
Token processComment(CommentToken token) {
 // For most phases the following is correct. Where it's not it will be
 // overridden.
 tree.insertComment(token, tree.openElements.last);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="processDoctype">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>processDoctype</strong>(<a href="../token/DoctypeToken.html">DoctypeToken</a> token) <a class="anchor-link" href="#processDoctype"
              title="Permalink to InBodyPhase.processDoctype">#</a></h4>
<div class="inherited-from">inherited from <a href="../parser/Phase.html">Phase</a> </div><div class="doc">
<pre class="source">
Token processDoctype(DoctypeToken token) {
 parser.parseError(token.span, "unexpected-doctype");
}
</pre>
</div>
</div>
<div class="method"><h4 id="processEndTag">
<button class="show-code">Code</button>
dynamic <strong>processEndTag</strong>(<a href="../token/EndTagToken.html">EndTagToken</a> token) <a class="anchor-link" href="#processEndTag"
              title="Permalink to InBodyPhase.processEndTag">#</a></h4>
<div class="doc">
<pre class="source">
processEndTag(EndTagToken token) {
 switch (token.name) {
   case "body": return endTagBody(token);
   case "html": return endTagHtml(token);
   case "address": case "article": case "aside": case "blockquote":
   case "center": case "details": case "dir": case "div": case "dl":
   case "fieldset": case "figcaption": case "figure": case "footer":
   case "header": case "hgroup": case "listing": case "menu": case "nav":
   case "ol": case "pre": case "section": case "summary": case "ul":
     return endTagBlock(token);
   case "form": return endTagForm(token);
   case "p": return endTagP(token);
   case "dd": case "dt": case "li": return endTagListItem(token);
   // headingElements
   case "h1": case "h2": case "h3": case "h4": case "h5": case "h6":
     return endTagHeading(token);
   case "a": case "b": case "big": case "code": case "em": case "font":
   case "i": case "nobr": case "s": case "small": case "strike":
   case "strong": case "tt": case "u":
     return endTagFormatting(token);
   case "applet": case "marquee": case "object":
     return endTagAppletMarqueeObject(token);
   case "br": return endTagBr(token);
     default: return endTagOther(token);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="processEOF">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>processEOF</strong>() <a class="anchor-link" href="#processEOF"
              title="Permalink to InBodyPhase.processEOF">#</a></h4>
<div class="doc">
<pre class="source">
bool processEOF() {
 for (Node node in tree.openElements.reversed) {
   switch (node.tagName) {
     case "dd": case "dt": case "li": case "p": case "tbody": case "td":
     case "tfoot": case "th": case "thead": case "tr": case "body":
     case "html":
       continue;
   }
   parser.parseError(node.sourceSpan, "expected-closing-tag-but-got-eof");
   break;
 }
 //Stop parsing
 return false;
}
</pre>
</div>
</div>
<div class="method"><h4 id="processSpaceCharacters">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>processSpaceCharacters</strong>(<a href="../token/SpaceCharactersToken.html">SpaceCharactersToken</a> token) <a class="anchor-link" href="#processSpaceCharacters"
              title="Permalink to InBodyPhase.processSpaceCharacters">#</a></h4>
<div class="doc">
<pre class="source">
Token processSpaceCharacters(SpaceCharactersToken token) {
 if (dropNewline) {
   processSpaceCharactersDropNewline(token);
 } else {
   tree.reconstructActiveFormattingElements();
   tree.insertText(token.data, token.span);
 }
 return null;
}
</pre>
</div>
</div>
<div class="method"><h4 id="processSpaceCharactersDropNewline">
<button class="show-code">Code</button>
void <strong>processSpaceCharactersDropNewline</strong>(<a href="../token/StringToken.html">StringToken</a> token) <a class="anchor-link" href="#processSpaceCharactersDropNewline"
              title="Permalink to InBodyPhase.processSpaceCharactersDropNewline">#</a></h4>
<div class="doc">
<pre class="source">
void processSpaceCharactersDropNewline(StringToken token) {
 // Sometimes (start of &lt;pre&gt;, &lt;listing&gt;, and &lt;textarea&gt; blocks) we
 // want to drop leading newlines
 var data = token.data;
 dropNewline = false;
 if (data.startsWith("\n")) {
   var lastOpen = tree.openElements.last;
   if (const ["pre", "listing", "textarea"].contains(lastOpen.tagName)
       &amp;&amp; !lastOpen.hasContent()) {
     data = data.substring(1);
   }
 }
 if (data.length &gt; 0) {
   tree.reconstructActiveFormattingElements();
   tree.insertText(data, token.span);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="processStartTag">
<button class="show-code">Code</button>
dynamic <strong>processStartTag</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#processStartTag"
              title="Permalink to InBodyPhase.processStartTag">#</a></h4>
<div class="doc">
<pre class="source">
processStartTag(StartTagToken token) {
 switch (token.name) {
   case "html":
     return startTagHtml(token);
   case "base": case "basefont": case "bgsound": case "command": case "link":
   case "meta": case "noframes": case "script": case "style": case "title":
     return startTagProcessInHead(token);
   case "body":
     return startTagBody(token);
   case "frameset":
     return startTagFrameset(token);
   case "address": case "article": case "aside": case "blockquote":
   case "center": case "details": case "details": case "dir": case "div":
   case "dl": case "fieldset": case "figcaption": case "figure":
   case "footer": case "header": case "hgroup": case "menu": case "nav":
   case "ol": case "p": case "section": case "summary": case "ul":
     return startTagCloseP(token);
   // headingElements
   case "h1": case "h2": case "h3": case "h4": case "h5": case "h6":
     return startTagHeading(token);
   case "pre": case "listing":
     return startTagPreListing(token);
   case "form":
     return startTagForm(token);
   case "li": case "dd": case "dt":
     return startTagListItem(token);
   case "plaintext":
     return startTagPlaintext(token);
   case "a": return startTagA(token);
   case "b": case "big": case "code": case "em": case "font": case "i":
   case "s": case "small": case "strike": case "strong": case "tt": case "u":
     return startTagFormatting(token);
   case "nobr":
     return startTagNobr(token);
   case "button":
     return startTagButton(token);
   case "applet": case "marquee": case "object":
     return startTagAppletMarqueeObject(token);
   case "xmp":
     return startTagXmp(token);
   case "table":
     return startTagTable(token);
   case "area": case "br": case "embed": case "img": case "keygen":
   case "wbr":
     return startTagVoidFormatting(token);
   case "param": case "source": case "track":
     return startTagParamSource(token);
   case "input":
     return startTagInput(token);
   case "hr":
     return startTagHr(token);
   case "image":
     return startTagImage(token);
   case "isindex":
     return startTagIsIndex(token);
   case "textarea":
     return startTagTextarea(token);
   case "iframe":
     return startTagIFrame(token);
   case "noembed": case "noframes": case "noscript":
     return startTagRawtext(token);
   case "select":
     return startTagSelect(token);
   case "rp": case "rt":
     return startTagRpRt(token);
   case "option": case "optgroup":
     return startTagOpt(token);
   case "math":
     return startTagMath(token);
   case "svg":
     return startTagSvg(token);
   case "caption": case "col": case "colgroup": case "frame": case "head":
   case "tbody": case "td": case "tfoot": case "th": case "thead": case "tr":
     return startTagMisplaced(token);
   default: return startTagOther(token);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagA">
<button class="show-code">Code</button>
void <strong>startTagA</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagA"
              title="Permalink to InBodyPhase.startTagA">#</a></h4>
<div class="doc">
<pre class="source">
void startTagA(StartTagToken token) {
 var afeAElement = tree.elementInActiveFormattingElements("a");
 if (afeAElement != null) {
   parser.parseError(token.span, "unexpected-start-tag-implies-end-tag",
       {"startName": "a", "endName": "a"});
   endTagFormatting(new EndTagToken("a"));
   tree.openElements.remove(afeAElement);
   tree.activeFormattingElements.remove(afeAElement);
 }
 tree.reconstructActiveFormattingElements();
 addFormattingElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagAppletMarqueeObject">
<button class="show-code">Code</button>
void <strong>startTagAppletMarqueeObject</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagAppletMarqueeObject"
              title="Permalink to InBodyPhase.startTagAppletMarqueeObject">#</a></h4>
<div class="doc">
<pre class="source">
void startTagAppletMarqueeObject(StartTagToken token) {
 tree.reconstructActiveFormattingElements();
 tree.insertElement(token);
 tree.activeFormattingElements.add(Marker);
 parser.framesetOK = false;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagBody">
<button class="show-code">Code</button>
void <strong>startTagBody</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagBody"
              title="Permalink to InBodyPhase.startTagBody">#</a></h4>
<div class="doc">
<pre class="source">
void startTagBody(StartTagToken token) {
 parser.parseError(token.span, "unexpected-start-tag", {"name": "body"});
 if (tree.openElements.length == 1
     || tree.openElements[1].tagName != "body") {
   assert(parser.innerHTMLMode);
 } else {
   parser.framesetOK = false;
   token.data.forEach((attr, value) {
     tree.openElements[1].attributes.putIfAbsent(attr, () =&gt; value);
   });
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagButton">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>startTagButton</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagButton"
              title="Permalink to InBodyPhase.startTagButton">#</a></h4>
<div class="doc">
<pre class="source">
Token startTagButton(StartTagToken token) {
 if (tree.elementInScope("button")) {
   parser.parseError(token.span, "unexpected-start-tag-implies-end-tag",
     {"startName": "button", "endName": "button"});
   processEndTag(new EndTagToken("button"));
   return token;
 } else {
   tree.reconstructActiveFormattingElements();
   tree.insertElement(token);
   parser.framesetOK = false;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagCloseP">
<button class="show-code">Code</button>
void <strong>startTagCloseP</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagCloseP"
              title="Permalink to InBodyPhase.startTagCloseP">#</a></h4>
<div class="doc">
<pre class="source">
void startTagCloseP(StartTagToken token) {
 if (tree.elementInScope("p", variant: "button")) {
   endTagP(new EndTagToken("p"));
 }
 tree.insertElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagForm">
<button class="show-code">Code</button>
void <strong>startTagForm</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagForm"
              title="Permalink to InBodyPhase.startTagForm">#</a></h4>
<div class="doc">
<pre class="source">
void startTagForm(StartTagToken token) {
 if (tree.formPointer != null) {
   parser.parseError(token.span, "unexpected-start-tag", {"name": "form"});
 } else {
   if (tree.elementInScope("p", variant: "button")) {
     endTagP(new EndTagToken("p"));
   }
   tree.insertElement(token);
   tree.formPointer = tree.openElements.last;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagFormatting">
<button class="show-code">Code</button>
void <strong>startTagFormatting</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagFormatting"
              title="Permalink to InBodyPhase.startTagFormatting">#</a></h4>
<div class="doc">
<pre class="source">
void startTagFormatting(StartTagToken token) {
 tree.reconstructActiveFormattingElements();
 addFormattingElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagFrameset">
<button class="show-code">Code</button>
void <strong>startTagFrameset</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagFrameset"
              title="Permalink to InBodyPhase.startTagFrameset">#</a></h4>
<div class="doc">
<pre class="source">
void startTagFrameset(StartTagToken token) {
 parser.parseError(token.span, "unexpected-start-tag", {"name": "frameset"});
 if ((tree.openElements.length == 1 ||
     tree.openElements[1].tagName != "body")) {
   assert(parser.innerHTMLMode);
 } else if (parser.framesetOK) {
   if (tree.openElements[1].parent != null) {
     tree.openElements[1].parent.nodes.remove(tree.openElements[1]);
   }
   while (tree.openElements.last.tagName != "html") {
     tree.openElements.removeLast();
   }
   tree.insertElement(token);
   parser.phase = parser._inFramesetPhase;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagHeading">
<button class="show-code">Code</button>
void <strong>startTagHeading</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagHeading"
              title="Permalink to InBodyPhase.startTagHeading">#</a></h4>
<div class="doc">
<pre class="source">
void startTagHeading(StartTagToken token) {
 if (tree.elementInScope("p", variant: "button")) {
   endTagP(new EndTagToken("p"));
 }
 if (headingElements.contains(tree.openElements.last.tagName)) {
   parser.parseError(token.span, "unexpected-start-tag",
       {"name": token.name});
   tree.openElements.removeLast();
 }
 tree.insertElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagHr">
<button class="show-code">Code</button>
void <strong>startTagHr</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagHr"
              title="Permalink to InBodyPhase.startTagHr">#</a></h4>
<div class="doc">
<pre class="source">
void startTagHr(StartTagToken token) {
 if (tree.elementInScope("p", variant: "button")) {
   endTagP(new EndTagToken("p"));
 }
 tree.insertElement(token);
 tree.openElements.removeLast();
 token.selfClosingAcknowledged = true;
 parser.framesetOK = false;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="startTagHtml">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>startTagHtml</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagHtml"
              title="Permalink to InBodyPhase.startTagHtml">#</a></h4>
<div class="inherited-from">inherited from <a href="../parser/Phase.html">Phase</a> </div><div class="doc">
<pre class="source">
Token startTagHtml(StartTagToken token) {
 if (parser.firstStartTag == false &amp;&amp; token.name == "html") {
    parser.parseError(token.span, "non-html-root");
 }
 // XXX Need a check here to see if the first start tag token emitted is
 // this token... If it's not, invoke parser.parseError().
 token.data.forEach((attr, value) {
   tree.openElements[0].attributes.putIfAbsent(attr, () =&gt; value);
 });
 parser.firstStartTag = false;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagIFrame">
<button class="show-code">Code</button>
void <strong>startTagIFrame</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagIFrame"
              title="Permalink to InBodyPhase.startTagIFrame">#</a></h4>
<div class="doc">
<pre class="source">
void startTagIFrame(StartTagToken token) {
 parser.framesetOK = false;
 startTagRawtext(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagImage">
<button class="show-code">Code</button>
void <strong>startTagImage</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagImage"
              title="Permalink to InBodyPhase.startTagImage">#</a></h4>
<div class="doc">
<pre class="source">
void startTagImage(StartTagToken token) {
 // No really...
 parser.parseError(token.span, "unexpected-start-tag-treated-as",
     {"originalName": "image", "newName": "img"});
 processStartTag(new StartTagToken("img", data: token.data,
     selfClosing: token.selfClosing));
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagInput">
<button class="show-code">Code</button>
void <strong>startTagInput</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagInput"
              title="Permalink to InBodyPhase.startTagInput">#</a></h4>
<div class="doc">
<pre class="source">
void startTagInput(StartTagToken token) {
 var savedFramesetOK = parser.framesetOK;
 startTagVoidFormatting(token);
 if (asciiUpper2Lower(token.data["type"]) == "hidden") {
   //input type=hidden doesn't change framesetOK
   parser.framesetOK = savedFramesetOK;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagIsIndex">
<button class="show-code">Code</button>
void <strong>startTagIsIndex</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagIsIndex"
              title="Permalink to InBodyPhase.startTagIsIndex">#</a></h4>
<div class="doc">
<pre class="source">
void startTagIsIndex(StartTagToken token) {
 parser.parseError(token.span, "deprecated-tag", {"name": "isindex"});
 if (tree.formPointer != null) {
   return;
 }
 var formAttrs = {};
 var dataAction = token.data["action"];
 if (dataAction != null) {
   formAttrs["action"] = dataAction;
 }
 processStartTag(new StartTagToken("form", data: formAttrs));
 processStartTag(new StartTagToken("hr", data: {}));
 processStartTag(new StartTagToken("label", data: {}));
 // XXX Localization ...
 var prompt = token.data["prompt"];
 if (prompt == null) {
   prompt = "This is a searchable index. Enter search keywords: ";
 }
 processCharacters(new CharactersToken(prompt));
 var attributes = new LinkedHashMap.from(token.data);
 attributes.remove('action');
 attributes.remove('prompt');
 attributes["name"] = "isindex";
 processStartTag(new StartTagToken("input",
                 data: attributes, selfClosing: token.selfClosing));
 processEndTag(new EndTagToken("label"));
 processStartTag(new StartTagToken("hr", data: {}));
 processEndTag(new EndTagToken("form"));
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagListItem">
<button class="show-code">Code</button>
void <strong>startTagListItem</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagListItem"
              title="Permalink to InBodyPhase.startTagListItem">#</a></h4>
<div class="doc">
<pre class="source">
void startTagListItem(StartTagToken token) {
 parser.framesetOK = false;

 final stopNamesMap = const {"li": const ["li"],
                             "dt": const ["dt", "dd"],
                             "dd": const ["dt", "dd"]};
 var stopNames = stopNamesMap[token.name];
 for (Node node in tree.openElements.reversed) {
   if (stopNames.contains(node.tagName)) {
     parser.phase.processEndTag(new EndTagToken(node.tagName));
     break;
   }
   if (specialElements.contains(node.nameTuple) &amp;&amp;
       !const ["address", "div", "p"].contains(node.tagName)) {
     break;
   }
 }

 if (tree.elementInScope("p", variant: "button")) {
   parser.phase.processEndTag(new EndTagToken("p"));
 }

 tree.insertElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagMath">
<button class="show-code">Code</button>
void <strong>startTagMath</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagMath"
              title="Permalink to InBodyPhase.startTagMath">#</a></h4>
<div class="doc">
<pre class="source">
void startTagMath(StartTagToken token) {
 tree.reconstructActiveFormattingElements();
 parser.adjustMathMLAttributes(token);
 parser.adjustForeignAttributes(token);
 token.namespace = Namespaces.mathml;
 tree.insertElement(token);
 //Need to get the parse error right for the case where the token
 //has a namespace not equal to the xmlns attribute
 if (token.selfClosing) {
   tree.openElements.removeLast();
   token.selfClosingAcknowledged = true;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagMisplaced">
<button class="show-code">Code</button>
void <strong>startTagMisplaced</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagMisplaced"
              title="Permalink to InBodyPhase.startTagMisplaced">#</a></h4>
<div class="doc">
<p>Elements that should be children of other elements that have a
different insertion mode; here they are ignored
"caption", "col", "colgroup", "frame", "frameset", "head",
"option", "optgroup", "tbody", "td", "tfoot", "th", "thead",
"tr", "noscript"</p>
<pre class="source">
void startTagMisplaced(StartTagToken token) {
 parser.parseError(token.span, "unexpected-start-tag-ignored",
     {"name": token.name});
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagNobr">
<button class="show-code">Code</button>
void <strong>startTagNobr</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagNobr"
              title="Permalink to InBodyPhase.startTagNobr">#</a></h4>
<div class="doc">
<pre class="source">
void startTagNobr(StartTagToken token) {
 tree.reconstructActiveFormattingElements();
 if (tree.elementInScope("nobr")) {
   parser.parseError(token.span, "unexpected-start-tag-implies-end-tag",
     {"startName": "nobr", "endName": "nobr"});
   processEndTag(new EndTagToken("nobr"));
   // XXX Need tests that trigger the following
   tree.reconstructActiveFormattingElements();
 }
 addFormattingElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagOpt">
<button class="show-code">Code</button>
void <strong>startTagOpt</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagOpt"
              title="Permalink to InBodyPhase.startTagOpt">#</a></h4>
<div class="doc">
<pre class="source">
void startTagOpt(StartTagToken token) {
 if (tree.openElements.last.tagName == "option") {
   parser.phase.processEndTag(new EndTagToken("option"));
 }
 tree.reconstructActiveFormattingElements();
 parser.tree.insertElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagOther">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>startTagOther</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagOther"
              title="Permalink to InBodyPhase.startTagOther">#</a></h4>
<div class="doc">
<pre class="source">
Token startTagOther(StartTagToken token) {
 tree.reconstructActiveFormattingElements();
 tree.insertElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagParamSource">
<button class="show-code">Code</button>
void <strong>startTagParamSource</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagParamSource"
              title="Permalink to InBodyPhase.startTagParamSource">#</a></h4>
<div class="doc">
<pre class="source">
void startTagParamSource(StartTagToken token) {
 tree.insertElement(token);
 tree.openElements.removeLast();
 token.selfClosingAcknowledged = true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagPlaintext">
<button class="show-code">Code</button>
void <strong>startTagPlaintext</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagPlaintext"
              title="Permalink to InBodyPhase.startTagPlaintext">#</a></h4>
<div class="doc">
<pre class="source">
void startTagPlaintext(StartTagToken token) {
 if (tree.elementInScope("p", variant: "button")) {
   endTagP(new EndTagToken("p"));
 }
 tree.insertElement(token);
 parser.tokenizer.state = parser.tokenizer.plaintextState;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagPreListing">
<button class="show-code">Code</button>
void <strong>startTagPreListing</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagPreListing"
              title="Permalink to InBodyPhase.startTagPreListing">#</a></h4>
<div class="doc">
<pre class="source">
void startTagPreListing(StartTagToken token) {
 if (tree.elementInScope("p", variant: "button")) {
   endTagP(new EndTagToken("p"));
 }
 tree.insertElement(token);
 parser.framesetOK = false;
 dropNewline = true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagProcessInHead">
<button class="show-code">Code</button>
<a href="../token/Token.html">Token</a> <strong>startTagProcessInHead</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagProcessInHead"
              title="Permalink to InBodyPhase.startTagProcessInHead">#</a></h4>
<div class="doc">
<pre class="source">
Token startTagProcessInHead(StartTagToken token) {
 return parser._inHeadPhase.processStartTag(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagRawtext">
<button class="show-code">Code</button>
void <strong>startTagRawtext</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagRawtext"
              title="Permalink to InBodyPhase.startTagRawtext">#</a></h4>
<div class="doc">
<p>iframe, noembed noframes, noscript(if scripting enabled). </p>
<pre class="source">
void startTagRawtext(StartTagToken token) {
 parser.parseRCDataRawtext(token, "RAWTEXT");
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagRpRt">
<button class="show-code">Code</button>
void <strong>startTagRpRt</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagRpRt"
              title="Permalink to InBodyPhase.startTagRpRt">#</a></h4>
<div class="doc">
<pre class="source">
void startTagRpRt(StartTagToken token) {
 if (tree.elementInScope("ruby")) {
   tree.generateImpliedEndTags();
   var last = tree.openElements.last;
   if (last.tagName != "ruby") {
     parser.parseError(last.sourceSpan, 'undefined-error');
   }
 }
 tree.insertElement(token);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagSelect">
<button class="show-code">Code</button>
void <strong>startTagSelect</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagSelect"
              title="Permalink to InBodyPhase.startTagSelect">#</a></h4>
<div class="doc">
<pre class="source">
void startTagSelect(StartTagToken token) {
 tree.reconstructActiveFormattingElements();
 tree.insertElement(token);
 parser.framesetOK = false;

 if (parser._inTablePhase == parser.phase ||
     parser._inCaptionPhase == parser.phase ||
     parser._inColumnGroupPhase == parser.phase ||
     parser._inTableBodyPhase == parser.phase ||
     parser._inRowPhase == parser.phase ||
     parser._inCellPhase == parser.phase) {
   parser.phase = parser._inSelectInTablePhase;
 } else {
   parser.phase = parser._inSelectPhase;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagSvg">
<button class="show-code">Code</button>
void <strong>startTagSvg</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagSvg"
              title="Permalink to InBodyPhase.startTagSvg">#</a></h4>
<div class="doc">
<pre class="source">
void startTagSvg(StartTagToken token) {
 tree.reconstructActiveFormattingElements();
 parser.adjustSVGAttributes(token);
 parser.adjustForeignAttributes(token);
 token.namespace = Namespaces.svg;
 tree.insertElement(token);
 //Need to get the parse error right for the case where the token
 //has a namespace not equal to the xmlns attribute
 if (token.selfClosing) {
   tree.openElements.removeLast();
   token.selfClosingAcknowledged = true;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagTable">
<button class="show-code">Code</button>
void <strong>startTagTable</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagTable"
              title="Permalink to InBodyPhase.startTagTable">#</a></h4>
<div class="doc">
<pre class="source">
void startTagTable(StartTagToken token) {
 if (parser.compatMode != "quirks") {
   if (tree.elementInScope("p", variant: "button")) {
     processEndTag(new EndTagToken("p"));
   }
 }
 tree.insertElement(token);
 parser.framesetOK = false;
 parser.phase = parser._inTablePhase;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagTextarea">
<button class="show-code">Code</button>
void <strong>startTagTextarea</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagTextarea"
              title="Permalink to InBodyPhase.startTagTextarea">#</a></h4>
<div class="doc">
<pre class="source">
void startTagTextarea(StartTagToken token) {
 tree.insertElement(token);
 parser.tokenizer.state = parser.tokenizer.rcdataState;
 dropNewline = true;
 parser.framesetOK = false;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagVoidFormatting">
<button class="show-code">Code</button>
void <strong>startTagVoidFormatting</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagVoidFormatting"
              title="Permalink to InBodyPhase.startTagVoidFormatting">#</a></h4>
<div class="doc">
<pre class="source">
void startTagVoidFormatting(StartTagToken token) {
 tree.reconstructActiveFormattingElements();
 tree.insertElement(token);
 tree.openElements.removeLast();
 token.selfClosingAcknowledged = true;
 parser.framesetOK = false;
}
</pre>
</div>
</div>
<div class="method"><h4 id="startTagXmp">
<button class="show-code">Code</button>
void <strong>startTagXmp</strong>(<a href="../token/StartTagToken.html">StartTagToken</a> token) <a class="anchor-link" href="#startTagXmp"
              title="Permalink to InBodyPhase.startTagXmp">#</a></h4>
<div class="doc">
<pre class="source">
void startTagXmp(StartTagToken token) {
 if (tree.elementInScope("p", variant: "button")) {
   endTagP(new EndTagToken("p"));
 }
 tree.reconstructActiveFormattingElements();
 parser.framesetOK = false;
 parser.parseRCDataRawtext(token, "RAWTEXT");
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
