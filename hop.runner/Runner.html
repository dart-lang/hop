        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Runner class / hop.runner Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="hop.runner" data-type="Runner">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../hop.runner.html">hop.runner</a> &rsaquo; <a href="../hop.runner/Runner.html">Runner</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Runner</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Runner {
 /**
  * Runs a [Task] with the specificed [TaskRuntime].
  *
  * [runTask] handles a number of error cases, logs appropriate messages
  * to [context] and returns a corresponding [RunResult] when completed.
  */
 static Future&lt;RunResult&gt; runTask(TaskRuntime runtime, Task task,
     {bool throwExceptions: false}) {

   requireArgumentNotNull(runtime, 'runtime');
   requireArgumentNotNull(task, 'task');

   final start = new DateTime.now();
   runtime.addLog(Level.FINEST, 'Started at $start');

   return task.run(runtime)
       .then((value) {
         // TODO: remove these checks at some future version
         if(value == true) {
           runtime.addLog(Level.SEVERE, '`true` was returned from the task.\n'
               "It's possible that the task was trying to signal success using"
               "an old behavior.\nThis is no longer nessesary.");
         } else if(value == false) {
           runtime.addLog(Level.SEVERE, "`false` was returned from the task.\n"
               "It's possible that the task was trying to signal failure using"
               "an old behavior.\nTasks should signal failure using "
               "`TaskContext.fail`.");
         }

         return RunResult.SUCCESS;
       })
       .catchError((Object error, StackTrace stack) {
         if(error is TaskUsageException) {
           runtime.addLog(Level.SEVERE, error.message);
           // TODO: print usage here? Hmm...
           return RunResult.BAD_USAGE;
         } else if(error is TaskFailError) {
           runtime.addLog(Level.SEVERE, error.message);
           return RunResult.FAIL;
         } else {
           // has as exception, need to test this
           runtime.addLog(Level.SEVERE, 'Exception thrown by task');
           runtime.addLog(Level.SEVERE, error.toString());

           if(error is Error &amp;&amp; stack == null) {
             // TODO: should this ever be the case? Weird...
             stack = error.stackTrace;
           }

           if(stack != null) {
             runtime.addLog(Level.SEVERE, stack.toString());
           }
           return RunResult.EXCEPTION;
         }
       }, test: (_) {
         // if we're told to throw exceptions, then return false
         // ...and skip the catch block
         return !throwExceptions;
       })
       .whenComplete(() {
         final end = new DateTime.now();
         runtime.addLog(Level.FINEST, 'Finished at $end');
         final duration = end.difference(start);
         runtime.addLog(Level.FINER, 'Run time: $duration');
       });
 }

 /**
  * [run] exists primarily for testing [Task] implementations.
  *
  * If you want to use Hop in an app, see [runHop].
  *
  * If you want to run a specific [Task] in isolation, see [runTask].
  */
 static Future&lt;RunResult&gt; run(HopConfig config, {Level printAtLogLevel,
   bool throwTaskExceptions: false}) {
   requireArgumentNotNull(config, 'config');

   if(config.argResults.command != null) {
     // we're executing a command
     final subCommandArgResults = config.argResults.command;
     final taskName = subCommandArgResults.name;

     var tasks = config.taskRegistry.getTaskWithDependencies(taskName);
     assert(tasks.isNotEmpty);

     RunResult finalResult;

     return Future.forEach(tasks.keys, (String subTaskName) {
       if(finalResult != null &amp;&amp; finalResult != RunResult.SUCCESS) {
         config.contextPrint('Skipping $subTaskName');
         return null;
       }

       var task = tasks[subTaskName];

       ArgResults args;
       if (subTaskName == taskName) {
         args = subCommandArgResults;
       } else {
         var parser = new ArgParser();
         var subParser = parser.addCommand(subTaskName, task.argParser);
         args = subParser.parse([]);
       }

       return _runNamedTask(subTaskName, task, args, printAtLogLevel, config,
           throwTaskExceptions)
           .then((RunResult rr) {
             finalResult = rr;
           });
     })
     .then((_) {
       assert(finalResult != null);
       return finalResult;
     });

   } else if (config.argResults.rest.length == 0) {
     _printHelp(config.contextPrint, config.taskRegistry, config.parser);
     return new Future.value(RunResult.SUCCESS);
   } else {
     final taskName = config.argResults.rest[0];
     config.contextPrint('No task named "$taskName".');
     return new Future.value(RunResult.BAD_USAGE);
   }
 }

 static Future&lt;RunResult&gt; _runNamedTask(String name, Task task,
     ArgResults argResults, Level printAtLogLevel, HopConfig config,
     bool throwExceptions) {

   var runtime = new _TaskRuntime(name, argResults, config,
       printAtLevel: printAtLogLevel);

   return runTask(runtime, task, throwExceptions: throwExceptions)
       .then((RunResult result) =&gt; _logExitCode(config, result))
         .whenComplete(() {
           runtime.dispose();
         });
 }

 /**
  * Designed to be run [runHop] command in the [hop] library.
  */
 static Future&lt;RunResult&gt; runShell(List&lt;String&gt; mainArgs,
     TaskRegistry registry, String helpTaskName, Level printAtLogLevel) {

   // a bit ugly
   // the help task needs the parser and a print method
   // we can't get those until the help task is created
   // so we use this dummy object which the help task closure holds onto
   // then we update the values before the help task could ever be called
   // sorry. Weird, I know
   final helpArgs = new _HelpArgs(registry);

   // wire up help task
   if(helpTaskName != null) {
     assert(registry._helpTaskName == null);
     registry._helpTaskName = helpTaskName;
     registry.addTask(helpTaskName, _getHelpTask(helpArgs));
   }

   registry._freeze();

   final parser = _getParser(registry, Level.INFO);
   helpArgs.parser = parser;

   ArgResults args;
   try {
     args = tryArgsCompletion(mainArgs, parser);
   } on FormatException catch (ex, stack) {
     // TODO: try to guess if --no-color was passed in here?
     print("There was an error parsing the provided arguments");
     print(ex.message);
     print('');
     _printHelp(print, registry, parser);

     return new Future.value(RunResult.BAD_USAGE);
   }

   final bool useColor = args[_COLOR_FLAG];
   var prefixEnabled = args[_PREFIX_FLAG];
   var minLogLevel = _getLevel(args[_LOG_LEVEL_OPTION]);
   final _ConsolePrinter printer = new _ConsolePrinter(Zone.current.print,
       useColor, minLogLevel, prefixEnabled);

   final config = new HopConfig._internal(registry, parser, args, printer);
   helpArgs.printer = config.contextPrint;

   return Runner.run(config, printAtLogLevel: printAtLogLevel);
 }

 static RunResult _logExitCode(HopConfig ctx, RunResult result) {
   if (!result.success) {
     final msg = 'Task did not complete - ${result.name} (${result.exitCode})';
     ctx.contextPrint(new ShellString.withColor(msg, AnsiColor.RED));
   }
   return result;
 }


 static Level _getLevel(String logLevelOption) =&gt; Level.LEVELS
     .singleWhere((Level l) =&gt; l.name.toLowerCase() == logLevelOption);
}
</pre>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="runTask">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../hop.core/RunResult.html">RunResult</a>&gt; <strong>runTask</strong>(<a href="../hop.shared/TaskRuntime.html">TaskRuntime</a> runtime, <a href="../hop.core/Task.html">Task</a> task, {<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> throwExceptions: false}) <a class="anchor-link" href="#runTask"
              title="Permalink to Runner.runTask">#</a></h4>
<div class="doc">
<p>Runs a <a class="crossref" href="../hop.core/Task.html">Task</a> with the specificed <a class="crossref" href="../hop.shared/TaskRuntime.html">TaskRuntime</a>.</p>
<p><a class="crossref" href="../hop.runner/Runner.html#runTask">runTask</a> handles a number of error cases, logs appropriate messages
to <code>context</code> and returns a corresponding <a class="crossref" href="../hop.core/RunResult.html">RunResult</a> when completed.</p>
<pre class="source">
static Future&lt;RunResult&gt; runTask(TaskRuntime runtime, Task task,
   {bool throwExceptions: false}) {

 requireArgumentNotNull(runtime, 'runtime');
 requireArgumentNotNull(task, 'task');

 final start = new DateTime.now();
 runtime.addLog(Level.FINEST, 'Started at $start');

 return task.run(runtime)
     .then((value) {
       // TODO: remove these checks at some future version
       if(value == true) {
         runtime.addLog(Level.SEVERE, '`true` was returned from the task.\n'
             "It's possible that the task was trying to signal success using"
             "an old behavior.\nThis is no longer nessesary.");
       } else if(value == false) {
         runtime.addLog(Level.SEVERE, "`false` was returned from the task.\n"
             "It's possible that the task was trying to signal failure using"
             "an old behavior.\nTasks should signal failure using "
             "`TaskContext.fail`.");
       }

       return RunResult.SUCCESS;
     })
     .catchError((Object error, StackTrace stack) {
       if(error is TaskUsageException) {
         runtime.addLog(Level.SEVERE, error.message);
         // TODO: print usage here? Hmm...
         return RunResult.BAD_USAGE;
       } else if(error is TaskFailError) {
         runtime.addLog(Level.SEVERE, error.message);
         return RunResult.FAIL;
       } else {
         // has as exception, need to test this
         runtime.addLog(Level.SEVERE, 'Exception thrown by task');
         runtime.addLog(Level.SEVERE, error.toString());

         if(error is Error &amp;&amp; stack == null) {
           // TODO: should this ever be the case? Weird...
           stack = error.stackTrace;
         }

         if(stack != null) {
           runtime.addLog(Level.SEVERE, stack.toString());
         }
         return RunResult.EXCEPTION;
       }
     }, test: (_) {
       // if we're told to throw exceptions, then return false
       // ...and skip the catch block
       return !throwExceptions;
     })
     .whenComplete(() {
       final end = new DateTime.now();
       runtime.addLog(Level.FINEST, 'Finished at $end');
       final duration = end.difference(start);
       runtime.addLog(Level.FINER, 'Run time: $duration');
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="run">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../hop.core/RunResult.html">RunResult</a>&gt; <strong>run</strong>(<a href="../hop.runner/HopConfig.html">HopConfig</a> config, {<a href="../logging/Level.html">Level</a> printAtLogLevel, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> throwTaskExceptions: false}) <a class="anchor-link" href="#run"
              title="Permalink to Runner.run">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../hop.runner/Runner.html#run">run</a> exists primarily for testing <a class="crossref" href="../hop.core/Task.html">Task</a> implementations.</p>
<p>If you want to use Hop in an app, see <code>runHop</code>.</p>
<p>If you want to run a specific <a class="crossref" href="../hop.core/Task.html">Task</a> in isolation, see <a class="crossref" href="../hop.runner/Runner.html#runTask">runTask</a>.</p>
<pre class="source">
static Future&lt;RunResult&gt; run(HopConfig config, {Level printAtLogLevel,
 bool throwTaskExceptions: false}) {
 requireArgumentNotNull(config, 'config');

 if(config.argResults.command != null) {
   // we're executing a command
   final subCommandArgResults = config.argResults.command;
   final taskName = subCommandArgResults.name;

   var tasks = config.taskRegistry.getTaskWithDependencies(taskName);
   assert(tasks.isNotEmpty);

   RunResult finalResult;

   return Future.forEach(tasks.keys, (String subTaskName) {
     if(finalResult != null &amp;&amp; finalResult != RunResult.SUCCESS) {
       config.contextPrint('Skipping $subTaskName');
       return null;
     }

     var task = tasks[subTaskName];

     ArgResults args;
     if (subTaskName == taskName) {
       args = subCommandArgResults;
     } else {
       var parser = new ArgParser();
       var subParser = parser.addCommand(subTaskName, task.argParser);
       args = subParser.parse([]);
     }

     return _runNamedTask(subTaskName, task, args, printAtLogLevel, config,
         throwTaskExceptions)
         .then((RunResult rr) {
           finalResult = rr;
         });
   })
   .then((_) {
     assert(finalResult != null);
     return finalResult;
   });

 } else if (config.argResults.rest.length == 0) {
   _printHelp(config.contextPrint, config.taskRegistry, config.parser);
   return new Future.value(RunResult.SUCCESS);
 } else {
   final taskName = config.argResults.rest[0];
   config.contextPrint('No task named "$taskName".');
   return new Future.value(RunResult.BAD_USAGE);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="runShell">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../hop.core/RunResult.html">RunResult</a>&gt; <strong>runShell</strong>(<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt; mainArgs, <a href="../hop.runner/TaskRegistry.html">TaskRegistry</a> registry, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> helpTaskName, <a href="../logging/Level.html">Level</a> printAtLogLevel) <a class="anchor-link" href="#runShell"
              title="Permalink to Runner.runShell">#</a></h4>
<div class="doc">
<p>Designed to be run <code>runHop</code> command in the <code>hop</code> library.</p>
<pre class="source">
static Future&lt;RunResult&gt; runShell(List&lt;String&gt; mainArgs,
   TaskRegistry registry, String helpTaskName, Level printAtLogLevel) {

 // a bit ugly
 // the help task needs the parser and a print method
 // we can't get those until the help task is created
 // so we use this dummy object which the help task closure holds onto
 // then we update the values before the help task could ever be called
 // sorry. Weird, I know
 final helpArgs = new _HelpArgs(registry);

 // wire up help task
 if(helpTaskName != null) {
   assert(registry._helpTaskName == null);
   registry._helpTaskName = helpTaskName;
   registry.addTask(helpTaskName, _getHelpTask(helpArgs));
 }

 registry._freeze();

 final parser = _getParser(registry, Level.INFO);
 helpArgs.parser = parser;

 ArgResults args;
 try {
   args = tryArgsCompletion(mainArgs, parser);
 } on FormatException catch (ex, stack) {
   // TODO: try to guess if --no-color was passed in here?
   print("There was an error parsing the provided arguments");
   print(ex.message);
   print('');
   _printHelp(print, registry, parser);

   return new Future.value(RunResult.BAD_USAGE);
 }

 final bool useColor = args[_COLOR_FLAG];
 var prefixEnabled = args[_PREFIX_FLAG];
 var minLogLevel = _getLevel(args[_LOG_LEVEL_OPTION]);
 final _ConsolePrinter printer = new _ConsolePrinter(Zone.current.print,
     useColor, minLogLevel, prefixEnabled);

 final config = new HopConfig._internal(registry, parser, args, printer);
 helpArgs.printer = config.contextPrint;

 return Runner.run(config, printAtLogLevel: printAtLogLevel);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
